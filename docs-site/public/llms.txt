# Verity

> **For AI agents:** This file provides a complete overview. Add `.md` to any docs page URL to get raw markdown.

## Project Overview

Lean 4 EDSL for writing smart contracts with machine-checked proofs. Three-layer verified compilation pipeline: EDSL -> ContractSpec -> IR -> Yul -> EVM bytecode.

**Core**: Models contract state, storage operations, and `require` guards using explicit success/revert result type (`ContractResult`).

**Contracts**: 9 example contracts with formal verification covering correctness, conservation laws, and storage isolation.

**Compiler**: Declarative `ContractSpec` DSL compiles to Yul with verified IR generation. Solidity-compatible function selectors via keccak256.

## Quick Facts

- **Language**: Lean 4.15.0
- **Core Size**: 249 lines
- **Contracts**: SimpleStorage, Counter, Owned, SimpleToken, OwnedCounter, Ledger, SafeCounter, CryptoHash, ReentrancyExample
- **Theorems**: 296 across 9 categories (286 fully proven, 10 `sorry` placeholders in Ledger sum proofs)
- **Axioms**: 5 documented axioms (see AXIOMS.md) — keccak256, expression evaluation, address injectivity
- **Tests**: 299 Foundry tests, multi-seed differential testing (7 seeds), 8-shard parallel CI
- **Build**: `lake build` verifies all proofs
- **Repository**: https://github.com/Th0rgal/verity

## Architecture

```
Layer 1: EDSL Proofs     — Lean theorems about contract behavior
Layer 2: Compiler Proofs — ContractSpec -> IR preservation
Layer 3: IR -> Yul       — Statement/expression equivalence proofs
Trust:   Yul -> Bytecode — Via solc (validated by differential testing)
```

## Key Design

```lean
-- Contracts are functions: ContractState -> ContractResult
inductive ContractResult (α : Type) where
  | success : α → ContractState → ContractResult α
  | revert : String → ContractState → ContractResult α

-- Custom bind short-circuits on revert
def bind (x : Contract α) (f : α → Contract β) : Contract β :=
  fun s => match x.run s with
    | ContractResult.success a s' => (f a).run s'
    | ContractResult.revert msg s' => ContractResult.revert msg s'
```

## Theorem Breakdown

| Contract | Count | Key Properties |
|----------|-------|----------------|
| SimpleStorage | 20 | Store/retrieve roundtrip, state isolation |
| Counter | 28 | Arithmetic, composition, decrement-at-zero |
| Owned | 22 | Access control, ownership transfer |
| SimpleToken | 56 | Mint/transfer, supply conservation, storage isolation |
| OwnedCounter | 45 | Cross-pattern composition, lockout proofs |
| Ledger | 32 | Deposit/withdraw/transfer, balance conservation |
| SafeCounter | 25 | Overflow/underflow revert proofs |
| ReentrancyExample | 4 | Reentrancy vulnerability proof, supply invariant |
| Stdlib | 64 | safeMul/safeDiv correctness, automation lemmas |

## Proof Techniques

**Full unfolding**: Unfold entire operation chain with `simp only`, then apply guard conditions.

**Private helpers**: Pre-compute exact result states when guards pass.

**Conservation**: Use `List.countOcc` to account for duplicate addresses in exact sum equations.

**No Mathlib**: Manual `Nat.*` lemma chains replace `omega`, `ring`, `linarith`.

## CI Validation

The GitHub Actions workflow validates:
- All Lean proofs compile (`lake build`)
- No `sorry` in proof files (except documented Sum.lean/SumProofs.lean)
- All axioms documented in AXIOMS.md
- Property manifest in sync with Lean proofs
- All manifest theorems have tests (or documented exclusions)
- Storage layout consistency across EDSL/Spec/Compiler layers
- Selector hashes match specs
- Generated Yul compiles with solc
- Contract file structure validation
- Foundry tests pass (8 shards, 7 seeds)

## Documentation URLs

- Main: https://verity.thomasm.ar/
- Verification: https://verity.thomasm.ar/verification
- Research: https://verity.thomasm.ar/research
- Examples: https://verity.thomasm.ar/examples
- Core: https://verity.thomasm.ar/core
- Compiler: https://verity.thomasm.ar/compiler
- Guides: https://verity.thomasm.ar/guides/first-contract

Add `.md` to any URL for raw markdown (saves tokens).

## Trust Assumptions

See TRUST_ASSUMPTIONS.md for full analysis. Key trust boundaries:
- **Verified**: EDSL -> ContractSpec -> IR -> Yul
- **Trusted**: Yul -> Bytecode (via solc, validated by 70k+ differential tests)
- **Axioms**: 5 documented, all with soundness justification
- **External**: Lean 4 kernel, EVM specification alignment

## Known Limitations

- 10 `sorry` placeholders in Ledger sum property proofs (issue #65)
- No events, no gas modeling
- No nested mappings (can't express ERC-20 allowances yet)
- Self-transfer handled via delta-zero pattern (not separate logic)

## What's Next

1. Complete Ledger sum proofs (#65)
2. EVMYulLean UInt256 integration (#67)
3. ERC-20 standard token (#69)
4. Storage layout formalization (#84)
5. Gas cost modeling (#80)
