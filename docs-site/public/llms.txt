# Verity

> **For AI agents:** This file provides a complete overview. Add `.md` to any docs page URL to get raw markdown.

## Project Overview

Lean 4 EDSL for writing smart contracts with machine-checked proofs. Three-layer verified compilation pipeline: EDSL -> ContractSpec -> IR -> Yul -> EVM bytecode.

**Core**: Models contract state, storage operations, and `require` guards using explicit success/revert result type (`ContractResult`).

**Contracts**: 8 formally verified contracts (+ CryptoHash as unverified linker demo) covering correctness, conservation laws, and storage isolation.

**Compiler**: Declarative `ContractSpec` DSL compiles to Yul with verified IR generation. Solidity-compatible function selectors via keccak256.

## Quick Facts

- **Language**: Lean 4.15.0
- **Core Size**: 350 lines
- **Verified Contracts**: SimpleStorage, Counter, Owned, SimpleToken, OwnedCounter, Ledger, SafeCounter, ReentrancyExample (+ CryptoHash as unverified linker demo)
- **Theorems**: 370 across 9 categories (370 fully proven, 0 `sorry` placeholders)
- **Axioms**: 2 documented axioms (see AXIOMS.md) — keccak256, address injectivity
- **Tests**: 375 Foundry tests, multi-seed differential testing (7 seeds), 8-shard parallel CI
- **Build**: `lake build` verifies all proofs
- **Repository**: https://github.com/Th0rgal/verity

## Architecture

```
AST Bridge: Unified AST  — denote ast = edsl_fn (by rfl or bind_assoc)
Layer 1: EDSL Proofs      — Lean theorems about contract behavior
Layer 2: Compiler Proofs  — ContractSpec -> IR preservation
Layer 3: IR -> Yul        — Statement/expression equivalence proofs
Trust:   Yul -> Bytecode  — Via solc (validated by differential testing)
```

## Key Design

```lean
-- Contracts are functions: ContractState -> ContractResult
inductive ContractResult (α : Type) where
  | success : α → ContractState → ContractResult α
  | revert : String → ContractState → ContractResult α

-- Custom bind short-circuits on revert
def bind (x : Contract α) (f : α → Contract β) : Contract β :=
  fun s => match x.run s with
    | ContractResult.success a s' => (f a).run s'
    | ContractResult.revert msg s' => ContractResult.revert msg s'
```

## Theorem Breakdown

| Contract | Count | Key Properties |
|----------|-------|----------------|
| SimpleStorage | 20 | Store/retrieve roundtrip, state isolation |
| Counter | 28 | Arithmetic, composition, decrement-at-zero |
| Owned | 23 | Access control, ownership transfer |
| SimpleToken | 59 | Mint/transfer, supply conservation, storage isolation |
| OwnedCounter | 48 | Cross-pattern composition, lockout proofs |
| Ledger | 33 | Deposit/withdraw/transfer, balance conservation |
| SafeCounter | 25 | Overflow/underflow revert proofs |
| ReentrancyExample | 4 | Reentrancy vulnerability proof, supply invariant |
| Stdlib | 130 | safeMul/safeDiv correctness, automation lemmas |

## Proof Techniques

**Full unfolding**: Unfold entire operation chain with `simp only`, then apply guard conditions.

**Private helpers**: Pre-compute exact result states when guards pass.

**Conservation**: Use `List.countOcc` to account for duplicate addresses in exact sum equations.

**No Mathlib**: Manual `Nat.*` lemma chains replace `omega`, `ring`, `linarith`.

## CI Validation

The GitHub Actions workflow validates:
- All Lean proofs compile (`lake build`)
- No `sorry` in any proof files (all proofs complete)
- All axioms documented in AXIOMS.md
- Property manifest in sync with Lean proofs
- All manifest theorems have tests (or documented exclusions)
- Storage layout consistency across EDSL/Spec/Compiler layers
- Selector hashes match specs
- Generated Yul compiles with solc (including CryptoHash with linked libraries)
- Contract file structure and All.lean import validation
- Foundry tests pass (8 shards, 7 seeds)

## External Library Linking

Use the Linker to inject production Yul libraries (Poseidon, Groth16, etc.) into compiled contracts. Prove properties against simple placeholders in Lean, then swap in real implementations at compile time.

**Workflow**: EDSL placeholder (addition) → ContractSpec with `Expr.externalCall` → `--link lib.yul` at compile time → Yul with injected library functions.

**Example**: CryptoHash contract demonstrates the full pattern:
- EDSL: `Verity/Examples/CryptoHash.lean` (placeholder: `add a b`)
- Spec: `Compiler/Specs.lean` → `cryptoHashSpec` (calls `PoseidonT3_hash`)
- Library: `examples/external-libs/PoseidonT3.yul`
- Compile: `lake exe verity-compiler --link examples/external-libs/PoseidonT3.yul --link examples/external-libs/PoseidonT4.yul`

**Validation**: The Linker checks for duplicate names, builtin shadowing, unresolved external references, and call-site arity mismatches before injecting.

**Trust model**: Linked libraries are outside the proof boundary. Proofs establish: "If the library behaves like the placeholder, the contract is correct."

## Documentation URLs

- Main: https://verity.thomasm.ar/
- Verification: https://verity.thomasm.ar/verification
- Research: https://verity.thomasm.ar/research
- Examples: https://verity.thomasm.ar/examples
- Core: https://verity.thomasm.ar/core
- Compiler: https://verity.thomasm.ar/compiler
- Guides (First Contract): https://verity.thomasm.ar/guides/first-contract
- Guides (Linking Libraries): https://verity.thomasm.ar/guides/linking-libraries
- Guides (Debugging Proofs): https://verity.thomasm.ar/guides/debugging-proofs
- Add a Contract: https://verity.thomasm.ar/add-contract

Add `.md` to any URL for raw markdown (saves tokens).

## Trust Assumptions

See TRUST_ASSUMPTIONS.md for full analysis. Key trust boundaries:
- **Verified**: EDSL -> ContractSpec -> IR -> Yul
- **Trusted**: Yul -> Bytecode (via solc, validated by 70k+ differential tests)
- **Axioms**: 2 documented, all with soundness justification
- **External**: Lean 4 kernel, EVM specification alignment

## Known Limitations

- All proofs complete — Ledger sum properties proven in Conservation.lean (issue #65 resolved)
- No gas modeling
- Self-transfer handled via delta-zero pattern (not separate logic)

## DSL Capabilities (ContractSpec)

The ContractSpec DSL supports: if/else branching (`Stmt.ite`), bounded loops (`Stmt.forEach`), event emission (`Stmt.emit`), nested/double mappings (`Expr.mapping2`, `Stmt.setMapping2`), uint256-keyed mappings (`Expr.mappingUint`, `Stmt.setMappingUint`), internal function composition (`Stmt.internalCall`, `Expr.internalCall`), dynamic array/bytes parameters, and external library linking (`Expr.externalCall`).

## What's Next

1. Unified AST `contract` macro: generate AST + EDSL + bridge proof from single source (Phase 4 of #364)
2. Compiler AST → Yul: replace ContractSpec with unified AST for codegen (Phase 5 of #364)
3. EVMYulLean integration: upgrade Lean, replace Yul semantics (#294)
4. ERC-20 standard token (#69)
5. Address soundness: replace String with ByteArray (#253)
