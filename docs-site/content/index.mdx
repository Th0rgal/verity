---
title: Verity
description: A Lean 4 EDSL for writing human-readable specs and formally verified smart contract implementations
---

import { Callout } from 'nextra/components'

# Verity

<Callout type="info">
**Are you an AI?** Check [/llms.txt](/llms.txt) or add `.md` to any page URL to get raw markdown and save tokens.
</Callout>

## Vision

Write smart contracts three times:

1. **Human-readable specification** — What should the contract do?
2. **Implementation in Lean** — Code that matches the spec
3. **Formal proof** — Machine-checked verification that implementation meets specification

Then compile the verified Lean implementation to EVM bytecode with automatic IR generation.

<Callout type="success">
**✅ Compilation Milestone**: All contracts compile automatically from declarative specs to Yul/EVM bytecode. The compiler pipeline and Yul codegen preservation proofs live in `Compiler/Proofs/`. See [Compiler](/compiler) for details.
</Callout>

## Why Lean?

[Lean 4](https://lean-lang.org/) is a programming language and theorem prover. Code and proofs live in the same file, checked by the same compiler. Unlike traditional testing (which checks specific inputs), formal proofs verify all possible inputs.

This project uses Lean to:
- Define what smart contracts should do (specifications)
- Implement the contracts (executable code)
- Prove the implementations satisfy the specifications (theorems)

**Current status**: A compact EDSL core, 9 example contracts, 300 machine-checked theorems across the EDSL and compiler, and automatic compilation to EVM bytecode. 352 Foundry tests across 25 suites. 5 documented axioms (see [AXIOMS.md](https://github.com/Th0rgal/verity/blob/main/AXIOMS.md)), 12 `sorry` placeholders remaining in Ledger sum proofs ([#65](https://github.com/Th0rgal/verity/issues/65)). Foundry tests include unit, property, and differential checks with multi-seed coverage.

## The Three-Layer Structure

Each contract has three files:

**1. Specification** (`Verity/Specs/SimpleToken/Spec.lean`)
```lean
-- What should mint do?
def mint_spec (to : Address) (amount : Uint256) (s s' : ContractState) : Prop :=
  s'.storageMap 1 to = s.storageMap 1 to + amount ∧  -- balance increases
  s'.storage 2 = s.storage 2 + amount                 -- supply increases
```

**2. Implementation** (`Verity/Examples/SimpleToken.lean`)
```lean
-- How to implement mint
def mint (to : Address) (amount : Uint256) : Contract Unit := do
  onlyOwner
  let currentBalance ← getMapping balances to
  setMapping balances to (currentBalance + amount)
  let currentSupply ← getStorage totalSupply
  setStorage totalSupply (currentSupply + amount)
```

**3. Proof** (`Verity/Specs/SimpleToken/Proofs.lean`)
```lean
-- Proof that implementation satisfies specification
theorem mint_meets_spec (s : ContractState) (to : Address) (amount : Uint256)
  (h_owner : s.sender = s.storageAddr 0) :
  let s' := ((mint to amount).run s).snd
  mint_spec to amount s s' := by
  simp only [mint, onlyOwner, getMapping, setMapping, ...]
  simp [h_owner]
```

The Lean compiler verifies every proof. If a proof is wrong, compilation fails.

## Where things live

- **User-facing specs**: `Verity/Specs/<Name>/Spec.lean` (+ `Invariants.lean`)
- **Implementations (EDSL)**: `Verity/Examples/<Name>.lean`
- **User-facing proofs**: `Verity/Specs/<Name>/Proofs.lean`
- **Reusable proof infrastructure**: `Verity/Proofs/Stdlib/` (spec interpreter + automation)
- **Compiler specs (for codegen)**: `Compiler/Specs.lean` (separate from user specs)
- **Compiler proofs**: `Compiler/Proofs/` (IR generation + Yul preservation)

## Adding a Contract (Checklist)

Use `python3 scripts/generate_contract.py <Name>` to scaffold all boilerplate files, then:

1. Write a small, human-readable spec in `Verity/Specs/<Name>/Spec.lean`.
2. Add any invariants in `Verity/Specs/<Name>/Invariants.lean` (optional but encouraged).
3. Implement the contract in `Verity/Examples/<Name>.lean` using the EDSL.
4. Prove the implementation meets the spec in `Verity/Specs/<Name>/Proofs.lean`.
5. Add compiler-level spec glue in `Compiler/Specs.lean` and any IR/Yul proofs in `Compiler/Proofs/` if new patterns are introduced.
6. Add tests in `test/` (unit + property + differential if applicable).

See [Add a Contract](/add-contract) for the full guide.

## Example Contracts

Nine contracts are implemented and verified:

| Contract | Demonstrates |
|----------|--------------|
| SimpleStorage | Basic storage read/write, state isolation |
| Counter | Arithmetic operations, composition |
| SafeCounter | Overflow/underflow prevention with checked arithmetic |
| Owned | Access control patterns, ownership transfer |
| OwnedCounter | Combining patterns (owned + counter) |
| Ledger | Balance tracking, deposit/withdraw/transfer, conservation laws |
| SimpleToken | Token minting/transfer, supply conservation, storage isolation |
| ReentrancyExample | Reentrancy vulnerability vs safe withdrawal patterns |
| CryptoHash | External cryptographic library linking |

Plus a math standard library with safe arithmetic theorems (`safeMul`, `safeDiv`, etc.).

See [/verification](/verification) for the complete, always-current theorem list.

## Introduction to Formal Verification

**What's a theorem?** A mathematical statement that's been proven true. In this project, theorems are statements about smart contract behavior.

**What's a proof?** A step-by-step logical argument that shows why a theorem must be true. Lean checks every step.

**What's `sorry`?** A placeholder in Lean that says "I'll prove this later." It's how incomplete proofs compile. This project has 12 `sorry` in Ledger sum proofs — all other claims are fully proven.

**What are axioms?** Statements assumed true without proof. This project uses 5 documented axioms for keccak256 hashing, expression evaluation equivalence, and address injectivity — each with soundness justification in [AXIOMS.md](https://github.com/Th0rgal/verity/blob/main/AXIOMS.md).

Example proof technique (simplified):
```lean
-- Claim: After storing 42, retrieving gives 42
theorem store_retrieve : store 42 >> retrieve = pure 42 := by
  unfold store retrieve  -- Expand definitions
  simp                   -- Simplify with built-in rules
  -- Proof complete
```

## Documentation

- **[Verification](/verification)** — Full theorem list by contract
- **[Examples](/examples)** — The 9 contracts and what they demonstrate
- **[Core](/core)** — How the 257-line EDSL works
- **[Research](/research)** — Design decisions and proof techniques

## Learning Resources

- [Lean 4 Manual](https://lean-lang.org/lean4/doc/) — Official documentation
- [Theorem Proving in Lean 4](https://lean-lang.org/theorem_proving_in_lean4/) — Introductory book
- [Lean Zulip Chat](https://leanprover.zulipchat.com/) — Community forum
- [Lean GitHub](https://github.com/leanprover/lean4) — Source code and examples

## Project Links

- [GitHub Repository](https://github.com/Th0rgal/verity) — Source code
- [Build Status](https://github.com/Th0rgal/verity/actions) — CI verification runs
