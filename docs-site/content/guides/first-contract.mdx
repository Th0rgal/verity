---
title: Adding Your First Contract
description: Step-by-step tutorial for creating a verified smart contract in Verity
---

# Adding Your First Contract to Verity

**Time Required**: 2-3 hours for first contract
**Prerequisites**: Basic familiarity with Lean 4 syntax and smart contract concepts

This tutorial walks you through creating a complete verified smart contract from scratch. We'll build a **TipJar** contract — a simple balance ledger where users can deposit tips and check balances.

> **Why TipJar?** It uses the core EDSL features (mappings, `msgSender`, `require`, arithmetic) while staying simple enough to prove fully on your first attempt.

---

## Overview: The Verity Workflow

Every contract follows this path:

```
Specification → Implementation → Proofs → Compilation → Testing
     (30m)          (45m)         (1-2h)      (auto)      (30m)
```

**What you'll learn**:
- How to write formal specifications
- How to implement contracts in the EDSL
- How to prove correctness properties
- How to compile and test against deployed bytecode

---

## Phase 1: Setup (15 minutes)

### 1.1 Use the Scaffold Generator

The easiest way to start is with the scaffold generator:

```bash
python3 scripts/generate_contract.py TipJar \
  --fields "tips:mapping" \
  --functions "tip,getBalance"
```

This creates all required files:
- `Verity/Specs/TipJar/Spec.lean` — formal specification
- `Verity/Specs/TipJar/Invariants.lean` — state invariants
- `Verity/Specs/TipJar/Proofs.lean` — proof re-export
- `Verity/Examples/TipJar.lean` — EDSL implementation
- `Compiler/Proofs/SpecCorrectness/TipJar.lean` — compiler proofs
- `test/PropertyTipJar.t.sol` — Foundry tests

### 1.2 Or Create Files Manually

```bash
mkdir -p Verity/Specs/TipJar
touch Verity/Specs/TipJar/Spec.lean
touch Verity/Specs/TipJar/Invariants.lean
touch Verity/Specs/TipJar/Proofs.lean
touch Verity/Examples/TipJar.lean
touch Compiler/Proofs/SpecCorrectness/TipJar.lean
touch test/PropertyTipJar.t.sol
```

### 1.3 Our Contract Goal

We want to build a contract where:
- Users can deposit a tip (adding to their balance) via `tip(uint256)`
- Anyone can check a balance via `getBalance(address) → uint256`
- Each address has an independent balance
- Balances use EVM modular arithmetic (wrapping on overflow) — this matches EVM opcodes, not Solidity's default checked arithmetic

> **Tip**: For contracts that should match Solidity ^0.8 behavior, add `require` guards (see `SafeCounter` example).

---

## Phase 2: Write Specification (30 minutes)

Specifications describe **what** the contract should do, not **how** it does it.

### 2.1 Create the Spec File

Open `Verity/Specs/TipJar/Spec.lean`:

```lean
/-
  TipJar: Formal Specification

  Specifies deposit and balance-check behavior for a simple tip ledger.
-/

import Verity.Core
import Verity.Specs.Common
import Verity.EVM.Uint256
import Verity.Examples.TipJar

namespace Verity.Specs.TipJar

open Verity
open Verity.EVM.Uint256

/-- tip: increases sender's balance by amount -/
def tip_spec (amount : Uint256) (s s' : ContractState) : Prop :=
  -- Sender's balance increases by amount (modular arithmetic)
  s'.storageMap 0 s.sender = add (s.storageMap 0 s.sender) amount ∧
  -- No other mapping entries change
  storageMapUnchangedExceptKeyAtSlot 0 s.sender s s' ∧
  -- Non-mapping storage and context are preserved
  sameStorageAddrContext s s'

/-- getBalance: returns balance at given address, no state change -/
def getBalance_spec (addr : Address) (result : Uint256) (s : ContractState) : Prop :=
  result = s.storageMap 0 addr

end Verity.Specs.TipJar
```

**Key Concepts**:
- `s` is the initial state, `s'` is the final state after the operation
- `storageMap 0` refers to the mapping at storage slot 0
- `storageMapUnchangedExceptKeyAtSlot` says only one key changed at one slot
- `sameStorageAddrContext` says uint256 storage, address storage, and context are preserved
- `add` is EVM modular addition (wraps at 2^256)

### 2.2 Create Invariants File

Open `Verity/Specs/TipJar/Invariants.lean`:

```lean
/-
  TipJar: State Invariants

  Properties that hold across all operations.
-/

import Verity.Core
import Verity.Specs.Common

namespace Verity.Specs.TipJar

open Verity

-- Tip operations don't affect regular storage slots
def uint_storage_unchanged (s s' : ContractState) : Prop :=
  s'.storage = s.storage

-- Tip operations don't affect address storage
def addr_storage_unchanged (s s' : ContractState) : Prop :=
  s'.storageAddr = s.storageAddr

end Verity.Specs.TipJar
```

---

## Phase 3: Implement in EDSL (45 minutes)

Now we implement the contract using the EDSL. Every function in the EDSL is a `Contract` — a state-transforming computation that can succeed or revert.

### 3.1 Create EDSL Implementation

Open `Verity/Examples/TipJar.lean`:

```lean
/-
  TipJar: Deposit tips and check balances

  Demonstrates:
  - Mapping storage (Address → Uint256)
  - Sender identification via msgSender
  - EVM modular arithmetic

  Pattern: Simple balance ledger
-/

import Verity.Core
import Verity.EVM.Uint256

namespace Verity.Examples.TipJar

open Verity
open Verity.EVM.Uint256

-- Storage layout: tips mapping at slot 0
def tips : StorageSlot (Address → Uint256) := ⟨0⟩

-- Deposit a tip: add amount to sender's balance
def tip (amount : Uint256) : Contract Unit := do
  let sender ← msgSender
  let currentBalance ← getMapping tips sender
  setMapping tips sender (add currentBalance amount)

-- Look up balance for any address
def getBalance (addr : Address) : Contract Uint256 := do
  getMapping tips addr

-- Example: Alice tips 100, then we check her balance
def exampleUsage : Contract Uint256 := do
  tip 100
  getBalance "0xAlice"

#eval! (exampleUsage.run { defaultState with
  sender := "0xAlice",
  thisAddress := "0xTipJar"
}).getValue?
-- Expected output: some 100

end Verity.Examples.TipJar
```

**EDSL API reference** (from `Verity/Core.lean`):

| Function | Type | Description |
|----------|------|-------------|
| `msgSender` | `Contract Address` | Get transaction sender |
| `msgValue` | `Contract Uint256` | Get ETH value sent with call |
| `blockTimestamp` | `Contract Uint256` | Get current block timestamp |
| `getStorage s` | `Contract Uint256` | Read uint256 slot |
| `setStorage s val` | `Contract Unit` | Write uint256 slot |
| `getMapping s key` | `Contract Uint256` | Read mapping entry |
| `setMapping s key val` | `Contract Unit` | Write mapping entry |
| `getStorageAddr s` | `Contract Address` | Read address slot |
| `setStorageAddr s val` | `Contract Unit` | Write address slot |
| `require cond msg` | `Contract Unit` | Revert if condition is false |

> **Tip**: Use `defaultState` to create a zero-initialized state for testing:
> ```lean
> #eval! (myContract.run { defaultState with sender := "0xAlice" }).getValue?
> ```
> This avoids spelling out every field and stays valid when new fields are added.

### 3.2 Test the EDSL Implementation

```bash
lake build Verity.Examples.TipJar
```

If successful, the `#eval!` block evaluates and prints `some 100`.

---

## Phase 4: Prove Correctness (1-2 hours)

This is where formal verification happens. We prove that our implementation matches our specification.

### 4.1 Write Layer 1 Proofs

Open `Compiler/Proofs/SpecCorrectness/TipJar.lean`:

```lean
/-
  TipJar: Correctness proofs

  Prove that the EDSL implementation matches the formal specification.
-/

import Verity.Core
import Verity.EVM.Uint256
import Verity.Examples.TipJar
import Verity.Specs.TipJar.Spec

namespace Compiler.Proofs.SpecCorrectness.TipJar

open Verity
open Verity.EVM.Uint256
open Verity.Examples.TipJar
open Verity.Specs.TipJar

-- tip: implementation matches spec
theorem tip_meets_spec (s : ContractState) (amount : Uint256) :
    tip_spec amount s (((tip amount).run s).snd) := by
  simp [tip, tip_spec, tips, msgSender, getMapping, setMapping,
        bind, storageMapUnchangedExceptKeyAtSlot,
        storageMapUnchangedExceptKey, storageMapUnchangedExceptSlot,
        sameStorageAddrContext, Specs.sameStorage, Specs.sameStorageAddr,
        Specs.sameContext]
  constructor
  · simp [Contract.run]
  · constructor
    · constructor
      · intro other hne; simp [*]
      · intro other hne addr; simp [*]
    · simp

-- getBalance: returns the correct value
theorem getBalance_correct (s : ContractState) (addr : Address) :
    getBalance_spec addr (((getBalance addr).run s).fst) s := by
  simp [getBalance, getBalance_spec, tips, getMapping]

-- getBalance doesn't modify state
theorem getBalance_preserves_state (s : ContractState) (addr : Address) :
    ((getBalance addr).run s).snd = s := by
  simp [getBalance, tips, getMapping]

-- Roundtrip: tip then getBalance returns updated balance
theorem tip_getBalance_roundtrip (amount : Uint256) (s : ContractState) :
    let s' := ((tip amount).run s).snd
    ((getBalance s.sender).run s').fst = add (s.storageMap 0 s.sender) amount := by
  simp [tip, getBalance, tips, msgSender, getMapping, setMapping, bind]

end Compiler.Proofs.SpecCorrectness.TipJar
```

### 4.2 Create Proof Re-export

Open `Verity/Specs/TipJar/Proofs.lean`:

```lean
import Compiler.Proofs.SpecCorrectness.TipJar

/-
  Layer 1 proof re-export.
  This keeps the user-facing path stable while reusing the core proof module.
-/
```

### 4.3 Common Proof Patterns

Here are the tactics you'll use most often:

**Pattern 1: Simple proofs with simp**
```lean
theorem simple_property : ... := by
  simp [functionName, helperFunctions]
```

**Pattern 2: Proofs with case splits**
```lean
theorem conditional_property : ... := by
  unfold functionName
  split
  · -- Case 1: condition true
    simp [...]
  · -- Case 2: condition false
    simp [...]
```

**Pattern 3: Proofs requiring intermediate lemmas**
```lean
theorem main_property : ... := by
  have h1 := helper_lemma_1
  have h2 := helper_lemma_2
  simp [h1, h2, ...]
```

See [Proof Debugging Handbook](/guides/debugging-proofs) for common errors and fixes.

### 4.4 Build and Check Proofs

```bash
# Build all proofs
lake build

# Check for incomplete proofs
grep -r "sorry" Verity/Specs/TipJar/ Compiler/Proofs/SpecCorrectness/TipJar.lean
```

**Goal**: Zero `sorry` statements before moving to testing.

---

## Phase 5: Add to Compiler (15 minutes)

### 5.1 Add Compiler Spec

Add your contract to `Compiler/Specs.lean`:

```lean
def tipJarSpec : ContractSpec := {
  name := "TipJar"
  fields := [
    { name := "tips", ty := FieldType.mapping }
  ]
  constructor := none
  functions := [
    { name := "tip"
      params := [{ name := "amount", ty := ParamType.uint256 }]
      returnType := none
      body := [
        Stmt.setMapping "tips" Expr.caller
          (Expr.add (Expr.mapping "tips" Expr.caller) (Expr.param "amount")),
        Stmt.stop
      ]
    },
    { name := "getBalance"
      params := [{ name := "addr", ty := ParamType.address }]
      returnType := some FieldType.uint256
      body := [
        Stmt.return (Expr.mapping "tips" (Expr.param "addr"))
      ]
    }
  ]
}
```

### 5.2 Compute Function Selectors

Solidity function selectors are the first 4 bytes of `keccak256("functionName(paramTypes)")`. Verity computes them automatically at compile time using `scripts/keccak256.py`:

```bash
# Compute selectors for your functions
python3 scripts/keccak256.py "tip(uint256)" "getBalance(address)"
# Output: two hex values like 0xd3e5769a 0xf8b2cb4f
```

Add the selectors and register in `allSpecs`:

```lean
-- Selectors must match the order of functions in tipJarSpec.functions
def tipJarSelectors : List Nat := [0xd3e5769a, 0xf8b2cb4f]

-- Add to allSpecs list
def allSpecs := [
  -- ... existing contracts ...,
  (tipJarSpec, tipJarSelectors)
]
```

> **Important**: The selector list must be in the same order as the functions list. `#guard` statements in `Specs.lean` enforce that the counts match, but order correctness is the developer's responsibility. Run `python3 scripts/check_selectors.py` to validate.

### 5.3 Generate Yul Code

```bash
lake build verity-compiler
lake exe verity-compiler

# Check output
ls compiler/yul/TipJar.yul
```

### 5.4 Verify Compilation

```bash
python3 scripts/check_yul_compiles.py
```

---

## Phase 6: Testing (30 minutes)

### 6.1 Create Property Tests

Open `test/PropertyTipJar.t.sol`:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.33;

import "forge-std/Test.sol";

/**
 * @title PropertyTipJar
 * @notice Property tests matching Lean theorems
 */
contract PropertyTipJar is Test {
    // Deploy the compiled Yul contract here
    // See test/PropertyCounter.t.sol for the full pattern

    /// @custom:property tip_meets_spec
    function testProp_TipUpdatesBalance(uint256 amount) public {
        // Verify tip updates sender's balance correctly
    }

    /// @custom:property getBalance_correct
    function testProp_GetBalanceReturnsCorrect(address addr) public {
        // Verify getBalance returns the stored value
    }

    /// @custom:property getBalance_preserves_state
    function testProp_GetBalanceReadOnly(address addr) public {
        // Verify getBalance doesn't modify storage
    }

    /// @custom:property tip_getBalance_roundtrip
    function testProp_Roundtrip(uint256 amount) public {
        // Verify tip then getBalance returns updated value
    }
}
```

> **Tip**: Look at `test/PropertyLedger.t.sol` for a complete example of mapping-based property tests.

### 6.2 Run Tests

```bash
forge test --match-contract TipJar -vv
```

### 6.3 Verify Property Coverage

```bash
python3 scripts/check_property_manifest.py
python3 scripts/report_property_coverage.py --format=markdown
```

---

## Phase 7: Integration & Validation (15 minutes)

### 7.1 Final Checklist

```bash
# 1. All Lean code compiles (including proofs)
lake build

# 2. No incomplete proofs
grep -r "sorry" Verity/Specs/TipJar/ Compiler/Proofs/SpecCorrectness/TipJar.lean

# 3. Yul generates and compiles
lake build verity-compiler
lake exe verity-compiler
python3 scripts/check_yul_compiles.py

# 4. Tests pass
forge test --match-contract TipJar

# 5. All CI checks pass
python3 scripts/check_selectors.py
python3 scripts/check_property_manifest.py
python3 scripts/check_doc_counts.py
```

### 7.2 Add to Module Exports

Update `Verity.lean`:
```lean
import Verity.Examples.TipJar
```

Update `Compiler.lean`:
```lean
import Compiler.Proofs.SpecCorrectness.TipJar
```

---

## Common Troubleshooting

### "Unknown identifier" in proofs

**Problem**: Lean can't find a function or type.

**Solution**: Check your imports and `open` statements:
```lean
import Verity.Core
import Verity.EVM.Uint256
import Verity.Examples.TipJar

open Verity
open Verity.EVM.Uint256
```

### "Type mismatch" errors

**Problem**: Wrong return type.

**Solution**: Check the function signature matches what you return:
```lean
def tip (amount : Uint256) : Contract Unit := do  -- Returns nothing
  ...

def getBalance (addr : Address) : Contract Uint256 := do  -- Returns Uint256
  ...
```

### Proofs don't close with `simp`

**Problem**: `simp` can't solve the goal.

**Solution**: Try `unfold` first to expose definitions, then `simp`:
```lean
theorem my_thm : ... := by
  unfold myFunction bind
  simp [getMapping, setMapping, msgSender, tips]
```

See [Proof Debugging Handbook](/guides/debugging-proofs) for more patterns.

### Tests fail with "selector not found"

**Problem**: Function selector mismatch between Lean and Solidity.

**Solution**:
```bash
python3 scripts/check_selectors.py
```

---

## Next Steps

1. **Add more properties**: Think of edge cases (zero amount, same sender/receiver)
2. **Add access control**: Look at `Verity/Examples/Owned.lean` for the `require` + owner pattern
3. **Add more functions**: Try adding a `withdraw` with balance checks (see `Verity/Examples/Ledger.lean`)
4. **Study existing contracts**: `SimpleStorage` (simplest), `Counter` (arithmetic), `Ledger` (mappings), `OwnedCounter` (composition)

### Learning Resources

- [Core Architecture](/core) — the full EDSL API reference
- [Compiler](/compiler) — how the compilation pipeline works
- [Proof Debugging Handbook](/guides/debugging-proofs) — common tactic failures and fixes
- [Lean 4 Manual](https://lean-lang.org/lean4/doc/) — language reference
- [Foundry Book](https://book.getfoundry.sh/) — testing framework
