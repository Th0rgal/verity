---
title: Linking External Libraries
description: How to use external Yul libraries (Poseidon, Groth16, etc.) with verified contracts
---

# Linking External Libraries

**Time Required**: 30 minutes
**Prerequisites**: Verity project builds (`lake build` passes)

## TL;DR

**Step 1** — Write your Yul library (plain functions, no `object` wrapper):
```bash
mkdir -p examples/external-libs
echo 'function myHash(a, b) -> result { result := add(xor(a, b), 0x42) }' > examples/external-libs/MyHash.yul
```

**Step 2** — Use a placeholder in your Lean EDSL (for proofs):
```lean
def myHash (a b : Uint256) : Contract Uint256 := return add a b
```

**Step 3** — Reference it in your ContractSpec:
```lean
Stmt.letVar "h" (Expr.externalCall "myHash" [Expr.param "a", Expr.param "b"])
```

**Step 4** — Compile with linking:
```bash
lake exe verity-compiler --link examples/external-libs/MyHash.yul -o compiler/yul
```

Your proofs verify the contract logic (using placeholders). Real implementations are injected at compile time.

---

## When to Use This

- You need **cryptographic primitives** (Poseidon hash, Groth16 verification, etc.) that are impractical to implement in Lean
- You want to **reuse audited Yul libraries** without re-implementing them
- You want to **prove contract logic** independently of complex library internals

## Quick Start

### 1. Write your library as a `.yul` file

Create a file with plain Yul function definitions (no `object` wrapper):

```yul
// examples/external-libs/MyHash.yul
function myHash(a, b) -> result {
    // Your implementation here
    result := add(xor(a, b), 0x42)
}
```

### 2. Write a placeholder in your Lean contract

In your EDSL contract, define a placeholder that models the same interface:

```lean
-- Placeholder for proofs: models the hash as addition
-- At compile time, replaced by the real myHash from MyHash.yul
def myHash (a b : Uint256) : Contract Uint256 := do
  return add a b
```

### 3. Add the external call to your ContractSpec

In `Compiler/Specs.lean`, use `Expr.externalCall` to reference the library function:

```lean
-- Inside your contract spec's function body:
Stmt.letVar "h" (Expr.externalCall "myHash" [Expr.param "a", Expr.param "b"])
```

> **Important**: `Expr.param` takes the parameter **name** as a string — it must match the `name` field in your function's `params` list. For example, if your function declares `{ name := "a", ty := ParamType.uint256 }`, use `Expr.param "a"`.

The compiler generates a Yul `myHash(a, b)` call that will be resolved by the linked library.

### 4. Compile with `--link`

```bash
lake exe verity-compiler --link examples/external-libs/MyHash.yul -o compiler/yul
```

The compiler validates that:
- No duplicate function names across libraries
- Library functions don't shadow generated code or Yul builtins
- All external calls in contracts are satisfied by linked libraries

If validation fails, you get a clear error message:

```
Unresolved external references: myHash
```

This means you forgot to pass `--link examples/external-libs/MyHash.yul`.

---

## Complete Example: CryptoHash Contract

Verity includes a working example in [`Verity/Examples/CryptoHash.lean`](https://github.com/Th0rgal/verity/blob/main/Verity/Examples/CryptoHash.lean) with libraries in [`examples/external-libs/`](https://github.com/Th0rgal/verity/tree/main/examples/external-libs).

**EDSL placeholder** (`Verity/Examples/CryptoHash.lean`):
```lean
-- Placeholder: just adds the inputs (for proving logic)
def hashTwo (a b : Uint256) : Contract Uint256 := do
  return add a b

def hashThree (a b c : Uint256) : Contract Uint256 := do
  return add (add a b) c

def storeHashTwo (a b : Uint256) : Contract Unit := do
  let h ← hashTwo a b
  setStorage lastHash h

def storeHashThree (a b c : Uint256) : Contract Unit := do
  let h ← hashThree a b c
  setStorage lastHash h
```

**External library** (`examples/external-libs/PoseidonT3.yul`):
```yul
function PoseidonT3_hash(a, b) -> result {
    result := add(xor(a, b), 0x1234...)
}
```

**Compile with linking**:
```bash
lake exe verity-compiler \
    --link examples/external-libs/PoseidonT3.yul \
    --link examples/external-libs/PoseidonT4.yul \
    -o compiler/yul
```

---

## How the Linker Works

The linking process has three stages:

### Stage 1: Parse libraries

The linker reads each `.yul` file and extracts function definitions using a line-based parser. It tracks brace depth to capture complete function bodies:

```
Input file:           Parsed output:
function foo() {  ->  LibraryFunction { name: "foo", body: [...] }
    sstore(0, 1)
}
```

### Stage 2: Validate

Four safety checks run before any code is injected:

| Check | What it catches |
|-------|-----------------|
| `validateNoDuplicateNames` | Two libraries defining the same function |
| `validateNoNameCollisions` | Library function shadowing `mappingSlot` or Yul builtins like `add`, `sstore` |
| `validateExternalReferences` | Contract calling a function not provided by any library |
| `validateCallArity` | Library function called with wrong number of arguments |

### Stage 3: Inject

Library functions are injected into the runtime `code {}` section of each compiled Yul contract, with proper indentation:

```yul
object "MyContract" {
    code { /* deploy */ }
    object "runtime" {
        code {
            // ... generated contract code ...

            // Injected from MyHash.yul:
            function myHash(a, b) -> result {
                result := add(xor(a, b), 0x42)
            }
        }
    }
}
```

---

## Library File Format

External library files must contain **plain Yul function definitions**:

```yul
// Good: plain function definitions
function foo(x) -> y {
    y := add(x, 1)
}

function bar(a, b) -> c {
    c := mul(a, b)
}
```

Do **not** wrap them in an `object` block:

```yul
// Bad: object wrapper not supported
object "MyLib" {
    code {
        function foo(x) -> y { y := add(x, 1) }
    }
}
```

---

## Trust Model

External libraries are **outside the formal verification boundary**. The Linker validates structural properties (no shadowing, all references resolved) but does not verify the library's correctness.

Your proofs establish: *"If the library functions behave like the placeholders, then the contract is correct."*

To increase confidence in linked libraries:
- Use audited, battle-tested implementations
- Add Foundry fuzz tests that exercise the linked contract end-to-end
- Document the trust assumption explicitly (see [`TRUST_ASSUMPTIONS.md`](https://github.com/Th0rgal/verity/blob/main/TRUST_ASSUMPTIONS.md))

---

## Common Issues and Debugging

### Function name mismatch

If you see `Unresolved external references: myFunc`, check that:
- The function name in your ContractSpec matches the Yul library exactly (case-sensitive)
- The library file is properly formatted with plain function definitions

### Arity mismatch

If you see `Arity mismatch: myFunc: called with N args but library defines M params`:
- The number of parameters in your `Expr.externalCall` must match the library function
- Remember: return values don't count as parameters

### Runtime errors with linked contracts

If your verified contract works with placeholders but fails with linked libraries:
1. **Check gas requirements**: Linked functions may use more gas than placeholders
2. **Verify return types**: Ensure the library returns the expected type
3. **Test with Foundry**: Add property tests that run against the linked contract

### Debugging tips

```bash
# Generate Yul output to see how external calls are rendered
lake exe verity-compiler --link examples/external-libs/MyLib.yul -o compiler/yul -v

# Check the generated Yul in compiler/yul/
cat compiler/yul/*.yul
```

---

## CLI Reference

```bash
lake exe verity-compiler [options]

Options:
  --link <path>      Link external Yul library (can be used multiple times)
  --output <dir>     Output directory (default: compiler/yul)
  -o <dir>           Short form of --output
  --verbose          Enable verbose output
  -v                 Short form of --verbose
  --help             Show help message
```

**Examples**:
```bash
# Compile without libraries
lake exe verity-compiler

# Compile with one library
lake exe verity-compiler --link examples/external-libs/PoseidonT3.yul

# Compile with multiple libraries, verbose output
lake exe verity-compiler \
    --link examples/external-libs/PoseidonT3.yul \
    --link examples/external-libs/PoseidonT4.yul \
    --link examples/external-libs/Groth16.yul \
    -v -o output/
```
