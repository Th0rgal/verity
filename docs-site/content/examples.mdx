---
title: Example Contracts
description: 7 contracts covering storage, arithmetic, access control, mappings, and composition
---

# Example Contracts

7 contracts, each introducing a new pattern. They build on each other: SimpleStorage uses one slot, Counter adds arithmetic, Owned adds access control, and SimpleToken combines all three.

## SimpleStorage

Single storage slot with get/set.

```lean
def storedData : StorageSlot Uint256 := ⟨0⟩

def store (value : Uint256) : Contract Unit := do
  setStorage storedData value

def retrieve : Contract Uint256 := do
  getStorage storedData
```

19 theorems (12 Basic + 7 Correctness). Proves store/retrieve roundtrip and state isolation.

## Counter

Read-modify-write with increment and decrement.

```lean
def count : StorageSlot Uint256 := ⟨0⟩

def increment : Contract Unit := do
  let current ← getStorage count
  setStorage count (current + 1)

def decrement : Contract Unit := do
  let current ← getStorage count
  setStorage count (current - 1)
```

29 theorems (19 Basic + 10 Correctness). Proves arithmetic, composition (two increments add 2), and decrement-at-zero behavior.

## SafeCounter

Same as Counter but uses checked arithmetic from `Stdlib/Math`.

```lean
def increment : Contract Unit := do
  let current ← getStorage count
  let newCount ← requireSomeUint (safeAdd current 1) "Overflow"
  setStorage count newCount
```

30 theorems (22 Basic + 8 Correctness). Proves overflow/underflow revert and bounds preservation.

## Owned

Access control with an owner address and a `require` guard.

```lean
def owner : StorageSlot Address := ⟨0⟩

def isOwner : Contract Bool := do
  let sender ← msgSender
  let currentOwner ← getStorageAddr owner
  return sender == currentOwner

def onlyOwner : Contract Unit := do
  let ownerCheck ← isOwner
  require ownerCheck "Caller is not the owner"
```

22 theorems (18 Basic + 4 Correctness). Proves access control enforcement and ownership transfer.

## OwnedCounter

Composes Owned and Counter. Increment/decrement require ownership.

```lean
def owner : StorageSlot Address := ⟨0⟩
def count : StorageSlot Uint256 := ⟨1⟩

def increment : Contract Unit := do
  onlyOwner
  let current ← getStorage count
  setStorage count (current + 1)
```

34 theorems (29 Basic + 5 Correctness). Proves cross-pattern composition, ownership transfer locking out old owner, and counter value surviving ownership transfer.

## Ledger

Mapping storage for per-address balances with deposit, withdraw, and transfer.

```lean
def balances : StorageSlot (Address → Uint256) := ⟨0⟩

def deposit (amount : Uint256) : Contract Unit := do
  let sender ← msgSender
  let currentBalance ← getMapping balances sender
  setMapping balances sender (currentBalance + amount)

def transfer (to : Address) (amount : Uint256) : Contract Unit := do
  let sender ← msgSender
  let senderBalance ← getMapping balances sender
  require (senderBalance >= amount) "Insufficient balance"
  let recipientBalance ← getMapping balances to
  setMapping balances sender (senderBalance - amount)
  setMapping balances to (recipientBalance + amount)
```

40 theorems (21 Basic + 6 Correctness + 13 Conservation). Proves balance guards, deposit/withdraw/transfer sum equations, and deposit-withdraw cancellation.

## SimpleToken

Composes Owned and Ledger. Adds owner-controlled minting and supply tracking.

```lean
def owner : StorageSlot Address := ⟨0⟩
def balances : StorageSlot (Address → Uint256) := ⟨1⟩
def totalSupply : StorageSlot Uint256 := ⟨2⟩

def mint (to : Address) (amount : Uint256) : Contract Unit := do
  onlyOwner
  let currentBalance ← getMapping balances to
  setMapping balances to (currentBalance + amount)
  let currentSupply ← getStorage totalSupply
  setStorage totalSupply (currentSupply + amount)

def transfer (to : Address) (amount : Uint256) : Contract Unit := do
  let sender ← msgSender
  let senderBalance ← getMapping balances sender
  require (senderBalance >= amount) "Insufficient balance"
  let recipientBalance ← getMapping balances to
  setMapping balances sender (senderBalance - amount)
  setMapping balances to (recipientBalance + amount)
```

64 theorems (36 Basic + 10 Correctness + 9 Supply conservation + 9 Isolation). Proves mint/transfer correctness, supply conservation equations, and storage isolation across all three slot types.

## Pattern progression

1. **SimpleStorage**: single slot
2. **Counter**: arithmetic
3. **SafeCounter**: stdlib integration
4. **Owned**: access control
5. **OwnedCounter**: composition (Owned + Counter)
6. **Ledger**: mapping storage
7. **SimpleToken**: full composition (Owned + Ledger + supply tracking)

## Source

All contracts are in [`DumbContracts/Examples/`](https://github.com/Th0rgal/dumbcontracts/tree/main/DumbContracts/Examples). Specs in `DumbContracts/Specs/`, proofs in `DumbContracts/Proofs/`.
