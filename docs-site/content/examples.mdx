---
title: Example Contracts
description: Contracts covering storage, arithmetic, access control, mappings, and composition
---

# Example Contracts

A small set of contracts, each introducing a new pattern. They build on each other: SimpleStorage uses one slot, Counter adds arithmetic, Owned adds access control, and SimpleToken combines all three.

## How to organize a contract

- **Spec**: `DumbContracts/Specs/<Name>/Spec.lean`
- **Implementation**: `DumbContracts/Examples/<Name>.lean`
- **Proof**: `DumbContracts/Specs/<Name>/Proofs.lean`
- **Reusable proof infra**: `DumbContracts/Proofs/Stdlib/`

Example (SimpleStorage):
- Spec: `DumbContracts/Specs/SimpleStorage/Spec.lean`
- Implementation: `DumbContracts/Examples/SimpleStorage.lean`
- Proof: `DumbContracts/Specs/SimpleStorage/Proofs.lean`

## Authoring checklist

1. Define behavior in `DumbContracts/Specs/<Name>/Spec.lean`.
2. Add invariants in `DumbContracts/Specs/<Name>/Invariants.lean` if needed.
3. Implement the EDSL contract in `DumbContracts/Examples/<Name>.lean`.
4. Prove spec adherence in `DumbContracts/Specs/<Name>/Proofs.lean` using `DumbContracts/Proofs/Stdlib/` helpers.

## SimpleStorage

Single storage slot with get/set.

```lean
def storedData : StorageSlot Uint256 := ⟨0⟩

def store (value : Uint256) : Contract Unit := do
  setStorage storedData value

def retrieve : Contract Uint256 := do
  getStorage storedData
```

Proofs cover store/retrieve roundtrip and state isolation.

## Counter

Read-modify-write with increment and decrement.

```lean
def count : StorageSlot Uint256 := ⟨0⟩

def increment : Contract Unit := do
  let current ← getStorage count
  setStorage count (current + 1)

def decrement : Contract Unit := do
  let current ← getStorage count
  setStorage count (current - 1)
```

Proofs cover arithmetic, composition (two increments add 2), and decrement-at-zero behavior.

## SafeCounter

Same as Counter but uses checked arithmetic from `Stdlib/Math`.

```lean
def increment : Contract Unit := do
  let current ← getStorage count
  let newCount ← requireSomeUint (safeAdd current 1) "Overflow"
  setStorage count newCount
```

Proofs cover overflow/underflow revert and bounds preservation.

## Owned

Access control with an owner address and a `require` guard.

```lean
def owner : StorageSlot Address := ⟨0⟩

def isOwner : Contract Bool := do
  let sender ← msgSender
  let currentOwner ← getStorageAddr owner
  return sender == currentOwner

def onlyOwner : Contract Unit := do
  let ownerCheck ← isOwner
  require ownerCheck "Caller is not the owner"
```

Proofs cover access control enforcement and ownership transfer.

## OwnedCounter

Composes Owned and Counter. Increment/decrement require ownership.

```lean
def owner : StorageSlot Address := ⟨0⟩
def count : StorageSlot Uint256 := ⟨1⟩

def increment : Contract Unit := do
  onlyOwner
  let current ← getStorage count
  setStorage count (current + 1)
```

Proofs cover cross-pattern composition, ownership transfer locking out old owner, and counter value surviving ownership transfer.

## Ledger

Mapping storage for per-address balances with deposit, withdraw, and transfer.

```lean
def balances : StorageSlot (Address → Uint256) := ⟨0⟩

def deposit (amount : Uint256) : Contract Unit := do
  let sender ← msgSender
  let currentBalance ← getMapping balances sender
  setMapping balances sender (currentBalance + amount)

def transfer (to : Address) (amount : Uint256) : Contract Unit := do
  let sender ← msgSender
  let senderBalance ← getMapping balances sender
  require (senderBalance >= amount) "Insufficient balance"
  let recipientBalance ← getMapping balances to
  setMapping balances sender (senderBalance - amount)
  setMapping balances to (recipientBalance + amount)
```

Proofs cover balance guards, deposit/withdraw/transfer sum equations, and deposit-withdraw cancellation.

## SimpleToken

Composes Owned and Ledger. Adds owner-controlled minting and supply tracking.

```lean
def owner : StorageSlot Address := ⟨0⟩
def balances : StorageSlot (Address → Uint256) := ⟨1⟩
def totalSupply : StorageSlot Uint256 := ⟨2⟩

def mint (to : Address) (amount : Uint256) : Contract Unit := do
  onlyOwner
  let currentBalance ← getMapping balances to
  setMapping balances to (currentBalance + amount)
  let currentSupply ← getStorage totalSupply
  setStorage totalSupply (currentSupply + amount)

def transfer (to : Address) (amount : Uint256) : Contract Unit := do
  let sender ← msgSender
  let senderBalance ← getMapping balances sender
  require (senderBalance >= amount) "Insufficient balance"
  let recipientBalance ← getMapping balances to
  setMapping balances sender (senderBalance - amount)
  setMapping balances to (recipientBalance + amount)
```

Proofs cover mint/transfer correctness, supply conservation equations, and storage isolation across all three slot types.

## Pattern progression

Snapshot (2026-02-13):

1. **SimpleStorage**: single slot
2. **Counter**: arithmetic
3. **SafeCounter**: stdlib integration
4. **Owned**: access control
5. **OwnedCounter**: composition (Owned + Counter)
6. **Ledger**: mapping storage
7. **SimpleToken**: full composition (Owned + Ledger + supply tracking)

## Source

All contracts are in [`DumbContracts/Examples/`](https://github.com/Th0rgal/dumbcontracts/tree/main/DumbContracts/Examples).
