---
title: Add a Contract
---

# Add a Contract (Spec → Proof → Compiler → Tests)

This is the shortest reliable path to add a new contract end-to-end, anchored to SimpleStorage.

## Quick Start: Scaffold Generator

Use the scaffold generator to create all boilerplate files at once:

```bash
# Simple contract with one uint256 field
python3 scripts/generate_contract.py MyContract

# Contract with typed fields
python3 scripts/generate_contract.py MyToken --fields "balances:mapping,totalSupply:uint256,owner:address"

# Contract with custom functions
python3 scripts/generate_contract.py MyToken --fields "balances:mapping" --functions "deposit,withdraw,getBalance"

# Preview without creating files
python3 scripts/generate_contract.py MyContract --dry-run
```

This creates 7 scaffold files (EDSL, Spec, Invariants, Proofs re-export shim, Basic proofs, Correctness proofs, Property tests) and prints the manual steps for `All.lean` and `Compiler/Specs.lean`.

## Checklist

1. **Spec**
   - Define interface and storage in `Verity/Specs/<Name>/Spec.lean`
   - Add invariants in `Verity/Specs/<Name>/Invariants.lean` (optional)
   - Align function signatures with Solidity types and storage slots

2. **EDSL Implementation**
   - Implement contract logic in `Verity/Examples/<Name>.lean`
   - Reuse helper lemmas for storage updates and mapping reads

3. **Layer 1 Proofs**
   - Prove correctness in `Verity/Proofs/<Name>/Basic.lean` and `Correctness.lean`
   - `Verity/Specs/<Name>/Proofs.lean` is a re-export shim (imports from `Verity/Proofs/`)
   - Each theorem states observable behavior (return values + storage deltas)

4. **Compiler Spec + Layer 2 Proofs**
   - Add compiler-level spec in `Compiler/Specs.lean`
   - Prove `ContractSpec → IR` preservation in `Compiler/Proofs/SpecCorrectness/<Name>.lean`

5. **Differential Tests**
   - Add harness in `test/Differential<Name>.t.sol`
   - Use shared config from `test/DiffTestConfig.sol`
   - Add edge-value tests using `_edgeUintValues()`

6. **Property Tests** (Proofs → Tests)
   - Add Foundry tests in `test/Property<Name>.t.sol`
   - Tag tests with `/// Property: theorem_name`
   - Verify with `python3 scripts/check_property_coverage.py`

## Expected File Layout

```
Verity/Specs/<Name>/
  ├── Spec.lean        # Function specifications
  ├── Invariants.lean  # State invariants (optional)
  └── Proofs.lean      # Layer 1 correctness proofs

Verity/Examples/<Name>.lean     # EDSL implementation
Compiler/Proofs/SpecCorrectness/<Name>.lean  # Layer 2 proofs
test/Differential<Name>.t.sol          # Differential tests
test/Property<Name>.t.sol              # Property tests
```

## Common Pitfalls

- **Storage slot mismatches** between spec, EDSL, and compiler
- **Missing selector updates** in `Compiler/Specs.lean` when adding functions
- **Mapping conversions** not mirrored between spec and proofs
- **Property tag drift** — test tags must match lemma names exactly

## Validation Checklist

```bash
# 1. Lean code compiles
lake build

# 2. Differential tests pass
FOUNDRY_PROFILE=difftest forge test --match-contract Differential<Name>

# 3. Property tests pass
FOUNDRY_PROFILE=difftest forge test --match-contract Property<Name>

# 4. Property manifest is in sync
python3 scripts/check_property_manifest.py
python3 scripts/check_property_coverage.py

# 5. Selectors are correct
python3 scripts/check_selectors.py
```

**Reference**: See [SimpleStorage](/examples#simplestorage) for a minimal end-to-end example.

**Need external libraries?** If your contract uses cryptographic primitives or other Yul functions, see [Linking External Libraries](/guides/linking-libraries) for the `--link` workflow. `CryptoHash` is a working end-to-end example.

## See also

- [Adding Your First Contract](/guides/first-contract) — step-by-step tutorial with TipJar
- [Linking External Libraries](/guides/linking-libraries) — if your contract uses Yul library functions
- [Proof Debugging Handbook](/guides/debugging-proofs) — when proofs get stuck
