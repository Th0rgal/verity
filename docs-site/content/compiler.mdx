---
title: Compiler
description: EDSL to EVM compilation with automatic IR generation
---

# Compiler

**Automatic compilation from verified EDSL to EVM bytecode.**

## Overview

The Verity compiler transforms high-level, verified contract specifications into deployable EVM bytecode. All contracts compile automatically from declarative specifications—no manual IR writing required.

**Pipeline**: EDSL Contract → Declarative Spec → IR → Yul → EVM Bytecode

**Spec sources**:
- User-facing specs: `Verity/Specs/<Name>/Spec.lean`
- Compiler specs (for codegen): `Compiler/Specs.lean` (generated/maintained separately)

## Trust Model

### What's Verified (Zero Trust Required)
- **EDSL + compiler proofs**: Lean theorems for contract specs, IR generation, and Yul codegen
- **Machine-checked proofs**: 2 documented axioms (see [AXIOMS.md](https://github.com/Th0rgal/verity/blob/main/AXIOMS.md)), 12 sorry in Ledger sum proofs
- **Interpreter semantics**: Spec, IR, and Yul semantics defined and linked in Lean

### What's Tested (High Confidence)
- **Compilation correctness**: Foundry unit and differential tests cover compiled contracts
- **Output validation**: Generated Yul is exercised against expected runtime behavior
- **Constructor handling**: Bytecode argument loading is covered in tests
- **Storage layout**: Automatic slot inference validated by examples

### What's Assumed (Trust Required)
- **Yul compiler**: Solidity's `solc` compiles Yul to bytecode correctly
- **EVM semantics**: Ethereum's execution model matches the spec used in proofs
- **Function selectors**: Pre-computed `keccak256` hashes are correct

### Roadmap
Roadmap, milestones, and progress updates live in `docs-site/content/research.mdx` and `docs-site/content/research/iterations.mdx`.

## Example: SimpleStorage

### EDSL Implementation
```lean
-- Verity/Examples/SimpleStorage.lean
def storedData : StorageSlot Uint256 := ⟨0⟩

def store (value : Uint256) : Contract Unit := do
  setStorage storedData value

def retrieve : Contract Uint256 := do
  getStorage storedData
```

### Declarative Specification
```lean
-- Compiler/Specs.lean
def simpleStorageSpec : ContractSpec := {
  name := "SimpleStorage"
  fields := [
    { name := "storedData", ty := FieldType.uint256 }
  ]
  constructor := none
  functions := [
    { name := "store"
      params := [{ name := "value", ty := ParamType.uint256 }]
      returnType := none
      body := [
        Stmt.setStorage "storedData" (Expr.param "value"),
        Stmt.stop
      ]
    },
    { name := "retrieve"
      params := []
      returnType := some FieldType.uint256
      body := [
        Stmt.return (Expr.storage "storedData")
      ]
    }
  ]
}
```

### Generated IR
```lean
-- Automatically generated (no manual writing)
{ name := "SimpleStorage"
  deploy := []
  functions := [
    { name := "store"
      selector := 0x6057361d
      params := [{ name := "value", ty := IRType.uint256 }]
      ret := IRType.unit
      body := [
        YulStmt.let_ "value" (YulExpr.call "calldataload" [YulExpr.lit 4]),
        YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 0, YulExpr.ident "value"]),
        YulStmt.expr (YulExpr.call "stop" [])
      ]
    },
    { name := "retrieve"
      selector := 0x2e64cec1
      params := []
      ret := IRType.uint256
      body := [
        YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 0]]),
        YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
      ]
    }
  ]
  usesMapping := false
}
```

### Generated Yul
```yul
// compiler/yul/SimpleStorage.yul
object "SimpleStorage" {
    code {
        datacopy(0, dataoffset("runtime"), datasize("runtime"))
        return(0, datasize("runtime"))
    }
    object "runtime" {
        code {
            switch shr(224, calldataload(0))
            case 0x6057361d {
                /* store() */
                let value := calldataload(4)
                sstore(0, value)
                stop()
            }
            case 0x2e64cec1 {
                /* retrieve() */
                mstore(0, sload(0))
                return(0, 32)
            }
            default {
                revert(0, 0)
            }
        }
    }
}
```

### Deployed Bytecode
```bash
# Compile Yul to bytecode
solc --strict-assembly SimpleStorage.yul

# Deploy to Ethereum (local, testnet, or mainnet)
forge create SimpleStorage --from 0x... --private-key ...
```

## Compiler Architecture

### Modules

**`Compiler/ContractSpec.lean`**
- Declarative contract DSL
- Expression language: `literal`, `param`, `storage`, `mapping`, `caller`, `msgValue`, `blockTimestamp`, `localVar`, `externalCall`, arithmetic, bitwise, comparisons
- Statement language: `letVar`, `setStorage`, `setMapping`, `require`, `return`, `stop`
- Automatic IR generation from specs
- Constructor parameter handling (bytecode argument loading)
- Storage slot inference (field order → slots 0, 1, 2, ...)

**`Compiler/Specs.lean`**
- Specifications for the example contracts
- Concise, type-safe, maintainable

**`Compiler/Selector.lean`**
- Function selector computation
- Pre-computed Solidity keccak256 hashes
- Type-safe signature generation

**`Compiler/Codegen.lean`**
- IR → Yul code generation
- Dispatcher generation (function selector switch)
- Mapping slot computation helper
- Deploy code + runtime code separation

**`Compiler/Linker.lean`**
- External Yul library linking
- Line-based parser for extracting function definitions from `.yul` files
- Injection of library functions into runtime code section
- Validation of external references (`validateExternalReferences`)

**`Compiler/Yul/*.lean`** (Yul AST + pretty printer)
- Yul abstract syntax tree
- Pretty printer (Yul → text)

### Compilation Process

1. **Specification**: Write declarative `ContractSpec`
2. **Storage Inference**: Assign slots 0, 1, 2, ... based on field order
3. **Selector Lookup**: Retrieve pre-computed function selectors
4. **IR Generation**: Compile expressions/statements to IR
5. **Code Generation**: Transform IR to Yul AST
6. **Pretty Print**: Render Yul AST as text
7. **Yul Compilation**: Use Solidity compiler (solc) to generate bytecode

## Features

### Automatic Storage Slot Inference ✅
```lean
fields := [
  { name := "owner", ty := FieldType.address },     -- slot 0
  { name := "balances", ty := FieldType.mapping },  -- slot 1
  { name := "totalSupply", ty := FieldType.uint256 } -- slot 2
]
```

No manual slot management needed. Compiler assigns slots based on field order.

### Constructor Parameters ✅
```lean
constructor := some {
  params := [{ name := "initialOwner", ty := ParamType.address }]
  body := [
    Stmt.setStorage "owner" (Expr.constructorArg 0)
  ]
}
```

Arguments loaded from end of deployment bytecode (Solidity convention).

### Function Selectors ✅
```lean
"store(uint256)" → 0x6057361d
"retrieve()" → 0x2e64cec1
```

Pre-computed from Solidity keccak256. Extensible for new functions.

### Type-Safe DSL ✅

The ContractSpec DSL provides a complete expression and statement language for specifying contract behavior.

**Expressions** (`Expr`) — 27 constructors:

| Constructor | Description | Yul Output |
|-------------|-------------|------------|
| `literal n` | Integer constant (mod 2^256) | `n` |
| `param "x"` | Function parameter | `x` (from calldata) |
| `constructorArg i` | Deploy-time argument | `argN` (from bytecode) |
| `storage "f"` | Read storage field | `sload(slot)` |
| `mapping "f" key` | Read mapping entry | `sload(mappingSlot(slot, key))` |
| `caller` | Transaction sender | `caller()` |
| `msgValue` | Sent ETH value | `callvalue()` |
| `blockTimestamp` | Current block timestamp | `timestamp()` |
| `localVar "x"` | Reference local variable | `x` |
| `externalCall "f" args` | Call linked library function | `f(args...)` |
| `add a b` | Addition | `add(a, b)` |
| `sub a b` | Subtraction | `sub(a, b)` |
| `mul a b` | Multiplication | `mul(a, b)` |
| `div a b` | Division | `div(a, b)` |
| `mod a b` | Modulo | `mod(a, b)` |
| `bitAnd a b` | Bitwise AND | `and(a, b)` |
| `bitOr a b` | Bitwise OR | `or(a, b)` |
| `bitXor a b` | Bitwise XOR | `xor(a, b)` |
| `bitNot a` | Bitwise NOT | `not(a)` |
| `shl s v` | Shift left | `shl(s, v)` |
| `shr s v` | Shift right | `shr(s, v)` |
| `eq a b` | Equal | `eq(a, b)` |
| `gt a b` | Greater than | `gt(a, b)` |
| `lt a b` | Less than | `lt(a, b)` |
| `ge a b` | Greater or equal | `iszero(lt(a, b))` |
| `le a b` | Less or equal | `iszero(gt(a, b))` |

**Statements** (`Stmt`) — 6 constructors:

| Constructor | Description | Yul Output |
|-------------|-------------|------------|
| `letVar "x" expr` | Declare local variable | `let x := expr` |
| `setStorage "f" expr` | Write storage field | `sstore(slot, expr)` |
| `setMapping "f" key val` | Write mapping entry | `sstore(mappingSlot(slot, key), val)` |
| `require cond "msg"` | Guard with revert message | `if iszero(cond) { revert(...) }` |
| `return expr` | Return value | `mstore(0, expr) return(0, 32)` |
| `stop` | End execution | `stop()` |

**Example** — combining multiple features:
```lean
Stmt.require (Expr.ge (Expr.mapping "balances" Expr.caller) (Expr.param "amount")) "Insufficient",
Stmt.setMapping "balances" Expr.caller
  (Expr.sub (Expr.mapping "balances" Expr.caller) (Expr.param "amount")),
Stmt.stop
```

### Code Optimization ✅
```yul
// Before (manual): Unnecessary variable
let current := sload(0)
sstore(0, add(current, 1))

// After (automatic): Inlined expression
sstore(0, add(sload(0), 1))
```

Automatic expression inlining reduces bytecode size and gas costs.

### External Library Linking ✅

Link production cryptographic libraries (or any external Yul functions) into compiled contracts using the `--link` flag:

```bash
lake exe verity-compiler \
    --link examples/external-libs/PoseidonT3.yul \
    --link examples/external-libs/PoseidonT4.yul \
    -o compiler/yul
```

**How it works**: The linker parses `.yul` files, extracts function definitions, and injects them into the runtime `code {}` section of each compiled contract. This lets you prove properties about contract logic using simple placeholder functions in Lean, then swap in production-grade implementations at compile time.

**Library file format**: External libraries should contain plain Yul function definitions (no `object` wrapper):
```yul
function PoseidonT3_hash(a, b) -> result {
    // Production implementation here
    result := /* ... */
}
```

**Validation**: The `validateExternalReferences` function checks that all non-builtin function calls in the contract are satisfied by linked libraries, catching missing dependencies at compile time.

See [`examples/external-libs/`](https://github.com/Th0rgal/verity/tree/main/examples/external-libs) for example library files.

## Usage

### Compile All Contracts
```bash
cd /path/to/verity
export PATH="$HOME/.elan/bin:$PATH"

# Build compiler
lake build verity-compiler

# Generate Yul for all contracts
lake exe verity-compiler

# Output: compiler/yul/*.yul
```

### Test Compiled Contracts
```bash
# Run all Foundry tests (difftest profile enables FFI for Yul compilation)
FOUNDRY_PROFILE=difftest forge test

# Expected: 352/352 tests pass (as of 2026-02-16)
```

### Add New Contract

1. **Define specification** in `Compiler/Specs.lean`:
```lean
def myContractSpec : ContractSpec := {
  name := "MyContract"
  fields := [/* ... */]
  constructor := /* ... */
  functions := [/* ... */]
}

def myContractSelectors : List Nat := [0x..., 0x...]

-- Add to allSpecs
def allSpecs := [
  /* ... */,
  (myContractSpec, myContractSelectors)
]
```

2. **Recompile**:
```bash
lake build verity-compiler
lake exe verity-compiler
```

3. **Done!** Contract generated in `compiler/yul/MyContract.yul`

Time: **~5 minutes** (vs ~30 minutes manual IR)

## Test Results

### All Tests Pass ✅

**Lean Proofs**: All proofs verified (305 EDSL theorems, 100%)
```bash
$ lake build
Build completed successfully.
```

**Foundry Tests**: 352/352 passing (100%, as of 2026-02-16)
```bash
$ forge test
Ran 25 test suites: 352 tests passed, 0 failed, 0 skipped (352 total tests)
```

**Coverage**: Unit, property, and differential tests across EDSL and compiled Yul. See `test/` for suites.

### Validated Contracts

All current example contracts compile and pass tests (as of Feb 16, 2026):
- ✅ **SimpleStorage** — Basic storage operations
- ✅ **Counter** — Arithmetic operations
- ✅ **Owned** — Access control with constructor args
- ✅ **OwnedCounter** — Pattern composition with constructor
- ✅ **Ledger** — Mapping-based balances
- ✅ **SimpleToken** — ERC20-like token with constructor
- ✅ **SafeCounter** — Checked arithmetic with underflow protection

**Not compiled**: ReentrancyExample (proofs are embedded inline, no compiler spec) and CryptoHash (unverified linker demo, requires `--link` to compile).

## Comparison: Manual vs Automatic

### Lines of Code
- **Before**: Manual IR for all contracts (brittle to maintain)
- **After**: Declarative specs for all contracts (stable, reusable)
- **Reduction**: Manual IR eliminated

### Time to Add Contract
- **Before**: Manual IR requires more steps (write IR, test, debug)
- **After**: Declarative specs reduce the setup and iteration work
- **Improvement**: Faster authoring and less surface for mistakes

### Code Quality
- **Before**: Manual Yul construction, error-prone
- **After**: Type-safe DSL, compile-time validation
- **Result**: More optimized, safer, maintainable

### Example: Owned Contract

**Before** (manual IR):
```lean
private def ownedContract : IRContract :=
  let deployBody := [
    stmtLet "argsOffset" (call "sub" [call "codesize" [], lit 32]),
    stmtExpr (call "codecopy" [lit 0, ident "argsOffset", lit 32]),
    stmtLet "initialOwner" (call "and" [call "mload" [lit 0], hex addressMask]),
    sstoreSlot 0 (ident "initialOwner")
  ]
  let transferBody := onlyOwnerCheck 0 ++ [
    stmtLet "newOwner" (calldataAddress 4),
    sstoreSlot 0 (ident "newOwner"),
    stop
  ]
  let getOwnerBody := returnUint (sloadSlot 0)
  { name := "Owned"
    deploy := deployBody
    functions := [
      fn "transferOwnership" 0xf2fde38b [addrParam "newOwner"] IRType.unit transferBody,
      fn "getOwner" 0x893d20e8 [] IRType.address getOwnerBody
    ]
    usesMapping := false }
```

**After** (declarative spec):
```lean
def ownedSpec : ContractSpec := {
  name := "Owned"
  fields := [
    { name := "owner", ty := FieldType.address }
  ]
  constructor := some {
    params := [{ name := "initialOwner", ty := ParamType.address }]
    body := [
      Stmt.setStorage "owner" (Expr.constructorArg 0)
    ]
  }
  functions := [
    { name := "transferOwnership"
      params := [{ name := "newOwner", ty := ParamType.address }]
      returnType := none
      body := [
        Stmt.require (Expr.eq Expr.caller (Expr.storage "owner")) "Not owner",
        Stmt.setStorage "owner" (Expr.param "newOwner"),
        Stmt.stop
      ]
    },
    { name := "getOwner"
      params := []
      returnType := some FieldType.address
      body := [
        Stmt.return (Expr.storage "owner")
      ]
    }
  ]
}
```

**Improvements**:
- 33% shorter
- Type-safe expressions
- No manual Yul construction
- Automatic slot/selector management

## Links

- [Research & Development](/research) — Design decisions and proof techniques
- [Examples](/examples) — 9 example contracts
- [Verification](/verification) — 305 proven theorems
- [GitHub Repository](https://github.com/Th0rgal/verity) — Source code
