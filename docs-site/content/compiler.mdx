---
title: Compiler
description: EDSL to EVM compilation with automatic IR generation
---

# Compiler

**Automatic compilation from verified EDSL to EVM bytecode.**

## Overview

The DumbContracts compiler transforms high-level, verified contract specifications into deployable EVM bytecode. All contracts compile automatically from declarative specifications—no manual IR writing required.

**Pipeline**: EDSL Contract → Declarative Spec → IR → Yul → EVM Bytecode

**Spec sources**:
- User-facing specs: `DumbContracts/Specs/<Name>/Spec.lean`
- Compiler specs (for codegen): `Compiler/Specs.lean` (generated/maintained separately)

## Trust Model

### What's Verified (Zero Trust Required)
- **EDSL + compiler proofs**: Lean theorems for contract specs, IR generation, and Yul codegen
- **Machine-checked proofs**: 5 documented axioms (see [AXIOMS.md](https://github.com/Th0rgal/dumbcontracts/blob/main/AXIOMS.md)), 12 sorry in Ledger sum proofs
- **Interpreter semantics**: Spec, IR, and Yul semantics defined and linked in Lean

### What's Tested (High Confidence)
- **Compilation correctness**: Foundry unit and differential tests cover compiled contracts
- **Output validation**: Generated Yul is exercised against expected runtime behavior
- **Constructor handling**: Bytecode argument loading is covered in tests
- **Storage layout**: Automatic slot inference validated by examples

### What's Assumed (Trust Required)
- **Yul compiler**: Solidity's `solc` compiles Yul to bytecode correctly
- **EVM semantics**: Ethereum's execution model matches the spec used in proofs
- **Function selectors**: Pre-computed `keccak256` hashes are correct

### Roadmap
Roadmap, milestones, and progress updates live in `docs-site/content/research.mdx` and `docs-site/content/research/iterations.mdx`.

## Example: SimpleStorage

### EDSL Implementation
```lean
-- DumbContracts/Examples/SimpleStorage.lean
def storedData : StorageSlot Uint256 := ⟨0⟩

def store (value : Uint256) : Contract Unit := do
  setStorage storedData value

def retrieve : Contract Uint256 := do
  getStorage storedData
```

### Declarative Specification
```lean
-- Compiler/Specs.lean
def simpleStorageSpec : ContractSpec := {
  name := "SimpleStorage"
  fields := [
    { name := "storedData", ty := FieldType.uint256 }
  ]
  constructor := none
  functions := [
    { name := "store"
      params := [{ name := "value", ty := ParamType.uint256 }]
      returnType := none
      body := [
        Stmt.setStorage "storedData" (Expr.param "value"),
        Stmt.stop
      ]
    },
    { name := "retrieve"
      params := []
      returnType := some FieldType.uint256
      body := [
        Stmt.return (Expr.storage "storedData")
      ]
    }
  ]
}
```

### Generated IR
```lean
-- Automatically generated (no manual writing)
{ name := "SimpleStorage"
  deploy := []
  functions := [
    { name := "store"
      selector := 0x6057361d
      params := [{ name := "value", ty := IRType.uint256 }]
      ret := IRType.unit
      body := [
        YulStmt.let_ "value" (YulExpr.call "calldataload" [YulExpr.lit 4]),
        YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 0, YulExpr.ident "value"]),
        YulStmt.expr (YulExpr.call "stop" [])
      ]
    },
    { name := "retrieve"
      selector := 0x2e64cec1
      params := []
      ret := IRType.uint256
      body := [
        YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 0]]),
        YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
      ]
    }
  ]
  usesMapping := false
}
```

### Generated Yul
```yul
// compiler/yul/SimpleStorage.yul
object "SimpleStorage" {
    code {
        datacopy(0, dataoffset("runtime"), datasize("runtime"))
        return(0, datasize("runtime"))
    }
    object "runtime" {
        code {
            switch shr(224, calldataload(0))
            case 0x6057361d {
                /* store() */
                let value := calldataload(4)
                sstore(0, value)
                stop()
            }
            case 0x2e64cec1 {
                /* retrieve() */
                mstore(0, sload(0))
                return(0, 32)
            }
            default {
                revert(0, 0)
            }
        }
    }
}
```

### Deployed Bytecode
```bash
# Compile Yul to bytecode
solc --strict-assembly SimpleStorage.yul

# Deploy to Ethereum (local, testnet, or mainnet)
forge create SimpleStorage --from 0x... --private-key ...
```

## Compiler Architecture

### Modules

**`Compiler/ContractSpec.lean`**
- Declarative contract DSL
- Expression language: `literal`, `param`, `storage`, `mapping`, `caller`, arithmetic, comparisons
- Statement language: `setStorage`, `setMapping`, `require`, `return`, `stop`
- Automatic IR generation from specs
- Constructor parameter handling (bytecode argument loading)
- Storage slot inference (field order → slots 0, 1, 2, ...)

**`Compiler/Specs.lean`**
- Specifications for the example contracts
- Concise, type-safe, maintainable

**`Compiler/Selector.lean`**
- Function selector computation
- Pre-computed Solidity keccak256 hashes
- Type-safe signature generation

**`Compiler/Codegen.lean`**
- IR → Yul code generation
- Dispatcher generation (function selector switch)
- Mapping slot computation helper
- Deploy code + runtime code separation

**`Compiler/Yul/*.lean`** (Yul AST + pretty printer)
- Yul abstract syntax tree
- Pretty printer (Yul → text)

### Compilation Process

1. **Specification**: Write declarative `ContractSpec`
2. **Storage Inference**: Assign slots 0, 1, 2, ... based on field order
3. **Selector Lookup**: Retrieve pre-computed function selectors
4. **IR Generation**: Compile expressions/statements to IR
5. **Code Generation**: Transform IR to Yul AST
6. **Pretty Print**: Render Yul AST as text
7. **Yul Compilation**: Use Solidity compiler (solc) to generate bytecode

## Features

### Automatic Storage Slot Inference ✅
```lean
fields := [
  { name := "owner", ty := FieldType.address },     -- slot 0
  { name := "balances", ty := FieldType.mapping },  -- slot 1
  { name := "totalSupply", ty := FieldType.uint256 } -- slot 2
]
```

No manual slot management needed. Compiler assigns slots based on field order.

### Constructor Parameters ✅
```lean
constructor := some {
  params := [{ name := "initialOwner", ty := ParamType.address }]
  body := [
    Stmt.setStorage "owner" (Expr.constructorArg 0)
  ]
}
```

Arguments loaded from end of deployment bytecode (Solidity convention).

### Function Selectors ✅
```lean
"store(uint256)" → 0x6057361d
"retrieve()" → 0x2e64cec1
```

Pre-computed from Solidity keccak256. Extensible for new functions.

### Type-Safe DSL ✅
```lean
// Expressions
Expr.literal 42
Expr.param "amount"
Expr.storage "count"
Expr.mapping "balances" Expr.caller
Expr.add (Expr.storage "count") (Expr.literal 1)

// Statements
Stmt.setStorage "count" (Expr.add (Expr.storage "count") (Expr.literal 1))
Stmt.require (Expr.eq Expr.caller (Expr.storage "owner")) "Not owner"
Stmt.return (Expr.storage "totalSupply")
```

Compile-time validation prevents errors.

### Code Optimization ✅
```yul
// Before (manual): Unnecessary variable
let current := sload(0)
sstore(0, add(current, 1))

// After (automatic): Inlined expression
sstore(0, add(sload(0), 1))
```

Automatic expression inlining reduces bytecode size and gas costs.

## Usage

### Compile All Contracts
```bash
cd /path/to/dumbcontracts
export PATH="$HOME/.elan/bin:$PATH"

# Build compiler
lake build dumbcontracts-compiler

# Generate Yul for all contracts
lake exe dumbcontracts-compiler

# Output: compiler/yul/*.yul
```

### Test Compiled Contracts
```bash
# Run all Foundry tests
forge test

# Expected: 290/290 tests pass (as of 2026-02-15)
```

### Add New Contract

1. **Define specification** in `Compiler/Specs.lean`:
```lean
def myContractSpec : ContractSpec := {
  name := "MyContract"
  fields := [/* ... */]
  constructor := /* ... */
  functions := [/* ... */]
}

def myContractSelectors : List Nat := [0x..., 0x...]

-- Add to allSpecs
def allSpecs := [
  /* ... */,
  (myContractSpec, myContractSelectors)
]
```

2. **Recompile**:
```bash
lake build dumbcontracts-compiler
lake exe dumbcontracts-compiler
```

3. **Done!** Contract generated in `compiler/yul/MyContract.yul`

Time: **~5 minutes** (vs ~30 minutes manual IR)

## Test Results

### All Tests Pass ✅

**Lean Proofs**: All proofs verified (296 EDSL theorems, 100%)
```bash
$ lake build
Build completed successfully.
```

**Foundry Tests**: 290/290 passing (100%, as of 2026-02-15)
```bash
$ forge test
Ran 23 test suites: 290 tests passed, 0 failed, 0 skipped (290 total tests)
```

**Coverage**: Unit, property, and differential tests across EDSL and compiled Yul. See `test/` for suites.

### Validated Contracts

All current example contracts compile and pass tests (as of Feb 13, 2026):
- ✅ **SimpleStorage** — Basic storage operations
- ✅ **Counter** — Arithmetic operations
- ✅ **Owned** — Access control with constructor args
- ✅ **OwnedCounter** — Pattern composition with constructor
- ✅ **Ledger** — Mapping-based balances
- ✅ **SimpleToken** — ERC20-like token with constructor
- ✅ **SafeCounter** — Checked arithmetic with underflow protection

## Comparison: Manual vs Automatic

### Lines of Code
- **Before**: Manual IR for all contracts (brittle to maintain)
- **After**: Declarative specs for all contracts (stable, reusable)
- **Reduction**: Manual IR eliminated

### Time to Add Contract
- **Before**: Manual IR requires more steps (write IR, test, debug)
- **After**: Declarative specs reduce the setup and iteration work
- **Improvement**: Faster authoring and less surface for mistakes

### Code Quality
- **Before**: Manual Yul construction, error-prone
- **After**: Type-safe DSL, compile-time validation
- **Result**: More optimized, safer, maintainable

### Example: Owned Contract

**Before** (manual IR):
```lean
private def ownedContract : IRContract :=
  let deployBody := [
    stmtLet "argsOffset" (call "sub" [call "codesize" [], lit 32]),
    stmtExpr (call "codecopy" [lit 0, ident "argsOffset", lit 32]),
    stmtLet "initialOwner" (call "and" [call "mload" [lit 0], hex addressMask]),
    sstoreSlot 0 (ident "initialOwner")
  ]
  let transferBody := onlyOwnerCheck 0 ++ [
    stmtLet "newOwner" (calldataAddress 4),
    sstoreSlot 0 (ident "newOwner"),
    stop
  ]
  let getOwnerBody := returnUint (sloadSlot 0)
  { name := "Owned"
    deploy := deployBody
    functions := [
      fn "transferOwnership" 0xf2fde38b [addrParam "newOwner"] IRType.unit transferBody,
      fn "getOwner" 0x893d20e8 [] IRType.address getOwnerBody
    ]
    usesMapping := false }
```

**After** (declarative spec):
```lean
def ownedSpec : ContractSpec := {
  name := "Owned"
  fields := [
    { name := "owner", ty := FieldType.address }
  ]
  constructor := some {
    params := [{ name := "initialOwner", ty := ParamType.address }]
    body := [
      Stmt.setStorage "owner" (Expr.constructorArg 0)
    ]
  }
  functions := [
    { name := "transferOwnership"
      params := [{ name := "newOwner", ty := ParamType.address }]
      returnType := none
      body := [
        Stmt.require (Expr.eq Expr.caller (Expr.storage "owner")) "Not owner",
        Stmt.setStorage "owner" (Expr.param "newOwner"),
        Stmt.stop
      ]
    },
    { name := "getOwner"
      params := []
      returnType := some FieldType.address
      body := [
        Stmt.return (Expr.storage "owner")
      ]
    }
  ]
}
```

**Improvements**:
- 33% shorter
- Type-safe expressions
- No manual Yul construction
- Automatic slot/selector management

## Links

- [Research & Development](/research) — Design decisions and proof techniques
- [Examples](/examples) — 9 example contracts
- [Verification](/verification) — 296 proven theorems
- [GitHub Repository](https://github.com/Th0rgal/dumbcontracts) — Source code
