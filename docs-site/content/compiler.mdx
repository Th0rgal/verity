---
title: Compiler
description: EDSL to EVM compilation with automatic IR generation
---

# Compiler

**Automatic compilation from verified EDSL to EVM bytecode.**

## Overview

The Verity compiler transforms high-level, verified contract specifications into deployable EVM bytecode. All contracts compile automatically from declarative specifications—no manual IR writing required.

**Pipeline**: EDSL Contract → Declarative Spec → IR → Yul → EVM Bytecode

**Spec sources**:
- User-facing specs: `Verity/Specs/<Name>/Spec.lean`
- Compiler specs (for codegen): `Compiler/Specs.lean` (generated/maintained separately)

## Trust Model

### What's Verified (Zero Trust Required)
- **EDSL + compiler proofs**: Lean theorems for contract specs, IR generation, and Yul codegen
- **Machine-checked proofs**: 2 documented axioms (see [AXIOMS.md](https://github.com/Th0rgal/verity/blob/main/AXIOMS.md)), 0 sorry — all proofs complete
- **Interpreter semantics**: Spec, IR, and Yul semantics defined and linked in Lean

### What's Tested (High Confidence)
- **Compilation correctness**: Foundry unit and differential tests cover compiled contracts
- **Output validation**: Generated Yul is exercised against expected runtime behavior
- **Constructor handling**: Bytecode argument loading is covered in tests
- **Storage layout**: Automatic slot inference validated by examples

### What's Assumed (Trust Required)
- **Yul compiler**: Solidity's `solc` compiles Yul to bytecode correctly
- **EVM semantics**: Ethereum's execution model matches the spec used in proofs
- **Function selectors**: Pre-computed `keccak256` hashes are correct

### Roadmap
Roadmap, milestones, and progress updates live in `docs-site/content/research.mdx` and `docs-site/content/research/iterations.mdx`.

## Example: SimpleStorage

### EDSL Implementation
```lean
-- Verity/Examples/SimpleStorage.lean
def storedData : StorageSlot Uint256 := ⟨0⟩

def store (value : Uint256) : Contract Unit := do
  setStorage storedData value

def retrieve : Contract Uint256 := do
  getStorage storedData
```

### Declarative Specification
```lean
-- Compiler/Specs.lean
def simpleStorageSpec : ContractSpec := {
  name := "SimpleStorage"
  fields := [
    { name := "storedData", ty := FieldType.uint256 }
  ]
  constructor := none
  functions := [
    { name := "store"
      params := [{ name := "value", ty := ParamType.uint256 }]
      returnType := none
      body := [
        Stmt.setStorage "storedData" (Expr.param "value"),
        Stmt.stop
      ]
    },
    { name := "retrieve"
      params := []
      returnType := some FieldType.uint256
      body := [
        Stmt.return (Expr.storage "storedData")
      ]
    }
  ]
}
```

### Generated IR
```lean
-- Automatically generated (no manual writing)
{ name := "SimpleStorage"
  deploy := []
  functions := [
    { name := "store"
      selector := 0x6057361d
      params := [{ name := "value", ty := IRType.uint256 }]
      ret := IRType.unit
      body := [
        YulStmt.let_ "value" (YulExpr.call "calldataload" [YulExpr.lit 4]),
        YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 0, YulExpr.ident "value"]),
        YulStmt.expr (YulExpr.call "stop" [])
      ]
    },
    { name := "retrieve"
      selector := 0x2e64cec1
      params := []
      ret := IRType.uint256
      body := [
        YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 0]]),
        YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
      ]
    }
  ]
  usesMapping := false
}
```

### Generated Yul
```yul
// compiler/yul/SimpleStorage.yul
object "SimpleStorage" {
    code {
        datacopy(0, dataoffset("runtime"), datasize("runtime"))
        return(0, datasize("runtime"))
    }
    object "runtime" {
        code {
            switch shr(224, calldataload(0))
            case 0x6057361d {
                /* store() */
                let value := calldataload(4)
                sstore(0, value)
                stop()
            }
            case 0x2e64cec1 {
                /* retrieve() */
                mstore(0, sload(0))
                return(0, 32)
            }
            default {
                revert(0, 0)
            }
        }
    }
}
```

### Deployed Bytecode
```bash
# Compile Yul to bytecode
solc --strict-assembly SimpleStorage.yul

# Deploy to Ethereum (local, testnet, or mainnet)
forge create SimpleStorage --from 0x... --private-key ...
```

## Compiler Architecture

### Modules

**`Compiler/ContractSpec.lean`**
- Declarative contract DSL
- Expression language: `literal`, `param`, `storage`, `mapping`, `mapping2`, `mappingUint`, `caller`, `msgValue`, `blockTimestamp`, `localVar`, `externalCall`, `internalCall`, `arrayLength`, `arrayElement`, arithmetic, bitwise, comparisons, logical operators
- Statement language: `letVar`, `assignVar`, `setStorage`, `setMapping`, `setMapping2`, `setMappingUint`, `require`, `return`, `stop`, `ite`, `forEach`, `emit`, `internalCall`
- Automatic IR generation from specs
- Constructor parameter handling (bytecode argument loading)
- Storage slot inference (field order → slots 0, 1, 2, ...)

**`Compiler/Specs.lean`**
- Specifications for the example contracts
- Concise, type-safe, maintainable

**`Compiler/Selector.lean`**
- Dynamic function selector computation via IO (calls `scripts/keccak256.py`)
- Type-safe Solidity signature generation from `FunctionSpec`

**`Compiler/Selectors.lean`**
- `keccak256_first_4_bytes` axiom (validated by CI against `solc --hashes`)
- Pre-computed selector constants for common functions

**`Compiler/Codegen.lean`**
- IR → Yul code generation
- Dispatcher generation (function selector switch)
- Mapping slot computation helper
- Deploy code + runtime code separation

**`Compiler/Linker.lean`**
- External Yul library linking
- Line-based parser for extracting function definitions from `.yul` files
- Injection of library functions into runtime code section
- Validation of external references (`validateExternalReferences`)

**`Compiler/Yul/*.lean`** (Yul AST + pretty printer)
- Yul abstract syntax tree
- Pretty printer (Yul → text)

### Compilation Process

1. **Specification**: Write declarative `ContractSpec`
2. **Storage Inference**: Assign slots 0, 1, 2, ... based on field order
3. **Selector Lookup**: Retrieve pre-computed function selectors
4. **IR Generation**: Compile expressions/statements to IR
5. **Code Generation**: Transform IR to Yul AST
6. **Pretty Print**: Render Yul AST as text
7. **Yul Compilation**: Use Solidity compiler (solc) to generate bytecode

## Features

### Automatic Storage Slot Inference ✅
```lean
fields := [
  { name := "owner", ty := FieldType.address },     -- slot 0
  { name := "balances", ty := FieldType.mapping },  -- slot 1
  { name := "totalSupply", ty := FieldType.uint256 } -- slot 2
]
```

No manual slot management needed. Compiler assigns slots based on field order.

### Constructor Parameters ✅
```lean
constructor := some {
  params := [{ name := "initialOwner", ty := ParamType.address }]
  body := [
    Stmt.setStorage "owner" (Expr.constructorArg 0)
  ]
}
```

Arguments loaded from end of deployment bytecode (Solidity convention).

### Function Selectors ✅
```lean
"store(uint256)" → 0x6057361d
"retrieve()" → 0x2e64cec1
```

Pre-computed from Solidity keccak256. Extensible for new functions.

### Type-Safe DSL ✅

The ContractSpec DSL provides a complete expression and statement language for specifying contract behavior.

**Expressions** (`Expr`) — 34 constructors:

| Constructor | Description | Yul Output |
|-------------|-------------|------------|
| `literal n` | Integer constant (mod 2^256) | `n` |
| `param "x"` | Function parameter | `x` (from calldata) |
| `constructorArg i` | Deploy-time argument | `argN` (from bytecode) |
| `storage "f"` | Read storage field | `sload(slot)` |
| `mapping "f" key` | Read mapping entry | `sload(mappingSlot(slot, key))` |
| `mapping2 "f" k1 k2` | Read nested mapping (e.g., allowances) | `sload(mappingSlot(mappingSlot(slot, k1), k2))` |
| `mappingUint "f" key` | Read uint256-keyed mapping | `sload(mappingSlot(slot, key))` |
| `caller` | Transaction sender | `caller()` |
| `msgValue` | Sent ETH value | `callvalue()` |
| `blockTimestamp` | Current block timestamp | `timestamp()` |
| `localVar "x"` | Reference local variable | `x` |
| `externalCall "f" args` | Call linked library function | `f(args...)` |
| `internalCall "f" args` | Call internal contract function | `internal_f(args...)` |
| `arrayLength "arr"` | Length of dynamic array parameter | `arr_length` |
| `arrayElement "arr" idx` | Element of dynamic array parameter | `calldataload(arr_data_offset + idx*32)` |
| `add a b` | Addition | `add(a, b)` |
| `sub a b` | Subtraction | `sub(a, b)` |
| `mul a b` | Multiplication | `mul(a, b)` |
| `div a b` | Division | `div(a, b)` |
| `mod a b` | Modulo | `mod(a, b)` |
| `bitAnd a b` | Bitwise AND | `and(a, b)` |
| `bitOr a b` | Bitwise OR | `or(a, b)` |
| `bitXor a b` | Bitwise XOR | `xor(a, b)` |
| `bitNot a` | Bitwise NOT | `not(a)` |
| `shl s v` | Shift left | `shl(s, v)` |
| `shr s v` | Shift right | `shr(s, v)` |
| `eq a b` | Equal | `eq(a, b)` |
| `gt a b` | Greater than | `gt(a, b)` |
| `lt a b` | Less than | `lt(a, b)` |
| `ge a b` | Greater or equal | `iszero(lt(a, b))` |
| `le a b` | Less or equal | `iszero(gt(a, b))` |
| `logicalAnd a b` | Short-circuit logical AND | `and(iszero(iszero(a)), iszero(iszero(b)))` |
| `logicalOr a b` | Short-circuit logical OR | `or(iszero(iszero(a)), iszero(iszero(b)))` |
| `logicalNot a` | Logical NOT | `iszero(a)` |

**Statements** (`Stmt`) — 13 constructors:

| Constructor | Description | Yul Output |
|-------------|-------------|------------|
| `letVar "x" expr` | Declare local variable | `let x := expr` |
| `assignVar "x" expr` | Reassign existing variable | `x := expr` |
| `setStorage "f" expr` | Write storage field | `sstore(slot, expr)` |
| `setMapping "f" key val` | Write mapping entry | `sstore(mappingSlot(slot, key), val)` |
| `setMapping2 "f" k1 k2 val` | Write nested mapping entry | `sstore(mappingSlot(mappingSlot(slot, k1), k2), val)` |
| `setMappingUint "f" key val` | Write uint256-keyed mapping | `sstore(mappingSlot(slot, key), val)` |
| `require cond "msg"` | Guard with revert message | `if iszero(cond) { revert(...) }` |
| `return expr` | Return value | `mstore(0, expr) return(0, 32)` |
| `stop` | End execution | `stop()` |
| `ite cond then else` | If/else branching | `if cond { then } if iszero(cond) { else }` |
| `forEach "i" count body` | Bounded loop | `for { let i := 0 } lt(i, count) { i := add(i,1) } { body }` |
| `emit "Event" args` | Emit event | `log1(ptr, size, topic0)` |
| `internalCall "f" args` | Call internal function (statement) | `internal_f(args...)` |

**Example** — combining multiple features:
```lean
-- Balance check with require
Stmt.require (Expr.ge (Expr.mapping "balances" Expr.caller) (Expr.param "amount")) "Insufficient",
Stmt.setMapping "balances" Expr.caller
  (Expr.sub (Expr.mapping "balances" Expr.caller) (Expr.param "amount")),
Stmt.stop
```

```lean
-- If/else branching
Stmt.ite (Expr.eq Expr.caller (Expr.storage "owner"))
  [Stmt.setStorage "paused" (Expr.literal 1), Stmt.stop]
  [Stmt.stop]  -- non-owner: no-op
```

```lean
-- Bounded loop over array
Stmt.forEach "i" (Expr.arrayLength "recipients")
  [Stmt.setMapping "balances" (Expr.arrayElement "recipients" (Expr.localVar "i"))
    (Expr.param "amount")]
```

### Code Optimization ✅
```yul
// Before (manual): Unnecessary variable
let current := sload(0)
sstore(0, add(current, 1))

// After (automatic): Inlined expression
sstore(0, add(sload(0), 1))
```

Automatic expression inlining reduces bytecode size and gas costs.

### External Library Linking ✅

Link production cryptographic libraries (or any external Yul functions) into compiled contracts using the `--link` flag:

```bash
lake exe verity-compiler \
    --link examples/external-libs/PoseidonT3.yul \
    --link examples/external-libs/PoseidonT4.yul \
    -o compiler/yul
```

**How it works**: The linker parses `.yul` files, extracts function definitions, and injects them into the runtime `code {}` section of each compiled contract. This lets you prove properties about contract logic using simple placeholder functions in Lean, then swap in production-grade implementations at compile time.

**Library file format**: External libraries should contain plain Yul function definitions (no `object` wrapper):
```yul
function PoseidonT3_hash(a, b) -> result {
    // Production implementation here
    result := /* ... */
}
```

**Validation**: The `validateExternalReferences` function checks that all non-builtin function calls in the contract are satisfied by linked libraries, catching missing dependencies at compile time.

See [`examples/external-libs/`](https://github.com/Th0rgal/verity/tree/main/examples/external-libs) for example library files.

### If/Else Branching

Conditional logic for contract functions:

```lean
-- Simple if (no else)
Stmt.ite (Expr.eq Expr.caller (Expr.storage "owner"))
  [Stmt.setStorage "paused" (Expr.literal 1)]
  []

-- If/else with both branches
Stmt.ite (Expr.gt (Expr.param "amount") (Expr.literal 0))
  [Stmt.setMapping "balances" Expr.caller
    (Expr.add (Expr.mapping "balances" Expr.caller) (Expr.param "amount"))]
  [-- else: revert on zero amount
   Stmt.require (Expr.literal 0) "Amount must be positive"]
```

Compiles to a block-scoped condition variable to avoid re-evaluation after state mutation:
```yul
{
    let __ite_cond := eq(caller(), sload(0))
    if __ite_cond { sstore(1, 1) }
    if iszero(__ite_cond) { /* else branch */ }
}
```

### Bounded Loops

Iterate over array parameters or fixed counts:

```lean
-- Iterate over a dynamic array
Stmt.forEach "i" (Expr.arrayLength "recipients")
  [Stmt.setMapping "balances"
    (Expr.arrayElement "recipients" (Expr.localVar "i"))
    (Expr.add
      (Expr.mapping "balances" (Expr.arrayElement "recipients" (Expr.localVar "i")))
      (Expr.param "amount"))]
```

Compiles to a Yul `for` loop:
```yul
for { let i := 0 } lt(i, recipients_length) { i := add(i, 1) } {
    sstore(mappingSlot(0, calldataload(add(recipients_data_offset, mul(i, 32)))),
           add(sload(mappingSlot(0, calldataload(add(recipients_data_offset, mul(i, 32))))), amount))
}
```

### Internal Functions

Define reusable logic shared across multiple external functions. Internal functions compile to Yul `function` definitions and are **not** exposed via selector dispatch:

```lean
def mySpec : ContractSpec := {
  name := "MyContract"
  fields := [{ name := "balances", ty := FieldType.mapping }]
  functions := [
    -- Internal helper (not exposed)
    { name := "addBalance"
      params := [{ name := "addr", ty := ParamType.address },
                 { name := "amt", ty := ParamType.uint256 }]
      returnType := none
      body := [
        Stmt.setMapping "balances" (Expr.param "addr")
          (Expr.add (Expr.mapping "balances" (Expr.param "addr"))
                    (Expr.param "amt"))
      ]
      isInternal := true  -- Not dispatched externally
    },
    -- External function that calls the helper
    { name := "deposit"
      params := []
      returnType := none
      body := [
        Stmt.internalCall "addBalance" [Expr.caller, Expr.msgValue],
        Stmt.stop
      ]
    }
  ]
}
```

Internal functions that return values use `__ret` assignment instead of EVM `RETURN`:
```lean
-- Internal function returning a value
{ name := "getBalance"
  params := [{ name := "addr", ty := ParamType.address }]
  returnType := some FieldType.uint256
  body := [Stmt.return (Expr.mapping "balances" (Expr.param "addr"))]
  isInternal := true
}

-- Call it from an expression context
Stmt.letVar "bal" (Expr.internalCall "getBalance" [Expr.caller])
```

### Event Emission

Emit EVM events for standards compliance (ERC20 Transfer/Approval, etc.):

```lean
def tokenSpec : ContractSpec := {
  name := "Token"
  fields := [{ name := "balances", ty := FieldType.mapping }]
  events := [
    { name := "Transfer"
      params := [
        { name := "from", ty := ParamType.address, kind := EventParamKind.indexed },
        { name := "to", ty := ParamType.address, kind := EventParamKind.indexed },
        { name := "amount", ty := ParamType.uint256, kind := EventParamKind.unindexed }
      ]
    }
  ]
  functions := [
    { name := "transfer"
      params := [{ name := "to", ty := ParamType.address },
                 { name := "amount", ty := ParamType.uint256 }]
      returnType := none
      body := [
        -- ... transfer logic ...
        Stmt.emit "Transfer" [Expr.caller, Expr.param "to", Expr.param "amount"],
        Stmt.stop
      ]
    }
  ]
}
```

Event topic0 is computed from the event signature (e.g., `keccak256("Transfer(address,address,uint256)")`). The compiler generates `log1` opcodes for events.

### Nested Mappings (Double Mappings)

For ERC20 allowances and similar patterns requiring `mapping(address => mapping(address => uint256))`:

```lean
fields := [
  { name := "allowances", ty := FieldType.mappingTyped (MappingType.nested .address .address) }
]

-- Read: allowances[owner][spender]
Expr.mapping2 "allowances" (Expr.param "owner") (Expr.param "spender")

-- Write: allowances[owner][spender] = amount
Stmt.setMapping2 "allowances" (Expr.param "owner") (Expr.param "spender") (Expr.param "amount")
```

Storage layout: `keccak256(spender . keccak256(owner . slot))` — matches Solidity nested mapping layout.

### Uint256-Keyed Mappings

For mappings keyed by numeric values instead of addresses:

```lean
fields := [
  { name := "data", ty := FieldType.mappingTyped (MappingType.simple .uint256) }
]

-- Read: data[tokenId]
Expr.mappingUint "data" (Expr.param "tokenId")

-- Write: data[tokenId] = value
Stmt.setMappingUint "data" (Expr.param "tokenId") (Expr.param "value")
```

### Array and Bytes Parameters

Dynamic arrays, fixed arrays, and bytes parameters for batch operations:

```lean
-- Dynamic array parameter
{ name := "recipients", ty := ParamType.array ParamType.address }

-- Fixed-size array parameter
{ name := "values", ty := ParamType.fixedArray ParamType.uint256 3 }

-- Dynamic bytes parameter
{ name := "data", ty := ParamType.bytes }

-- Access array elements in function body
Expr.arrayLength "recipients"          -- number of elements
Expr.arrayElement "recipients" (Expr.localVar "i")  -- element at index i
```

Dynamic arrays use ABI offset-based decoding. The compiler generates `_length` and `_data_offset` local variables automatically.

## Usage

### Compile All Contracts
```bash
cd /path/to/verity
export PATH="$HOME/.elan/bin:$PATH"

# Build compiler
lake build verity-compiler

# Generate Yul for all contracts
lake exe verity-compiler

# Output: compiler/yul/*.yul
```

### Test Compiled Contracts
```bash
# Run all Foundry tests (difftest profile enables FFI for Yul compilation)
FOUNDRY_PROFILE=difftest forge test

# Expected: 375/375 tests pass
```

### Add New Contract

1. **Define specification** in `Compiler/Specs.lean`:
```lean
def myContractSpec : ContractSpec := {
  name := "MyContract"
  fields := [/* ... */]
  constructor := /* ... */
  functions := [/* ... */]
}

-- Add to allSpecs (selectors are auto-computed from function signatures)
def allSpecs : List ContractSpec := [
  /* ... */,
  myContractSpec
]
```

2. **Recompile**:
```bash
lake build verity-compiler
lake exe verity-compiler
```

3. **Done!** Contract generated in `compiler/yul/MyContract.yul`

Time: **~5 minutes** (vs ~30 minutes manual IR)

## Test Results

### All Tests Pass ✅

**Lean Proofs**: All proofs verified (371 EDSL theorems, 100%)
```bash
$ lake build
Build completed successfully.
```

**Foundry Tests**: 375/375 passing (100%)
```bash
$ FOUNDRY_PROFILE=difftest forge test
Ran 32 test suites: 375 tests passed, 0 failed, 0 skipped (375 total tests)
```

**Coverage**: Unit, property, and differential tests across EDSL and compiled Yul. See `test/` for suites.

### Validated Contracts

All current example contracts compile and pass tests:
- ✅ **SimpleStorage** — Basic storage operations
- ✅ **Counter** — Arithmetic operations
- ✅ **Owned** — Access control with constructor args
- ✅ **OwnedCounter** — Pattern composition with constructor
- ✅ **Ledger** — Mapping-based balances
- ✅ **SimpleToken** — ERC20-like token with constructor
- ✅ **SafeCounter** — Checked arithmetic with underflow protection

**Not compiled**: ReentrancyExample (proofs are embedded inline, no compiler spec). CryptoHash compiles via `--link` with external Poseidon libraries and is validated in CI.

## Comparison: Manual vs Automatic

### Lines of Code
- **Before**: Manual IR for all contracts (brittle to maintain)
- **After**: Declarative specs for all contracts (stable, reusable)
- **Reduction**: Manual IR eliminated

### Time to Add Contract
- **Before**: Manual IR requires more steps (write IR, test, debug)
- **After**: Declarative specs reduce the setup and iteration work
- **Improvement**: Faster authoring and less surface for mistakes

### Code Quality
- **Before**: Manual Yul construction, error-prone
- **After**: Type-safe DSL, compile-time validation
- **Result**: More optimized, safer, maintainable

### Example: Owned Contract

**Before** (manual IR):
```lean
private def ownedContract : IRContract :=
  let deployBody := [
    stmtLet "argsOffset" (call "sub" [call "codesize" [], lit 32]),
    stmtExpr (call "codecopy" [lit 0, ident "argsOffset", lit 32]),
    stmtLet "initialOwner" (call "and" [call "mload" [lit 0], hex addressMask]),
    sstoreSlot 0 (ident "initialOwner")
  ]
  let transferBody := onlyOwnerCheck 0 ++ [
    stmtLet "newOwner" (calldataAddress 4),
    sstoreSlot 0 (ident "newOwner"),
    stop
  ]
  let getOwnerBody := returnUint (sloadSlot 0)
  { name := "Owned"
    deploy := deployBody
    functions := [
      fn "transferOwnership" 0xf2fde38b [addrParam "newOwner"] IRType.unit transferBody,
      fn "getOwner" 0x893d20e8 [] IRType.address getOwnerBody
    ]
    usesMapping := false }
```

**After** (declarative spec):
```lean
def ownedSpec : ContractSpec := {
  name := "Owned"
  fields := [
    { name := "owner", ty := FieldType.address }
  ]
  constructor := some {
    params := [{ name := "initialOwner", ty := ParamType.address }]
    body := [
      Stmt.setStorage "owner" (Expr.constructorArg 0)
    ]
  }
  functions := [
    { name := "transferOwnership"
      params := [{ name := "newOwner", ty := ParamType.address }]
      returnType := none
      body := [
        Stmt.require (Expr.eq Expr.caller (Expr.storage "owner")) "Not owner",
        Stmt.setStorage "owner" (Expr.param "newOwner"),
        Stmt.stop
      ]
    },
    { name := "getOwner"
      params := []
      returnType := some FieldType.address
      body := [
        Stmt.return (Expr.storage "owner")
      ]
    }
  ]
}
```

**Improvements**:
- 33% shorter
- Type-safe expressions
- No manual Yul construction
- Automatic slot/selector management

## Links

- [Research & Development](/research) — Design decisions and proof techniques
- [Examples](/examples) — 9 example contracts
- [Verification](/verification) — 371 proven theorems
- [GitHub Repository](https://github.com/Th0rgal/verity) — Source code
