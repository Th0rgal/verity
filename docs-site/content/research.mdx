---
title: Research & Development
description: Design decisions, iterations, and proof techniques
---

# Research & Development

**Compact core, built across 7 iterations. Zero sorry, zero axioms.**

## Evolution

The project evolved in two phases:

**Phase 1 (Iterations 1-7)**: Built 7 contracts on `StateM ContractState`. The core stayed intentionally small while storage types were added incrementally: `Nat -> Uint256` (iteration 1), `Nat -> Address` (iteration 3), `Nat -> Address -> Uint256` for mappings (iteration 6). Each addition was driven by a concrete example that needed it.

**Phase 2 (Verification)**: Replaced `StateM` with custom `ContractResult` type (`success | revert`) to model `require` guards explicitly. This enabled proving properties like "mint reverts when caller is not owner." The core expanded to include proof automation lemmas and EVM context fields.

## Progress and Roadmap (as of 2026-02-13)

This is the single source of truth for progress, roadmap, and milestone updates.

- **Layer 1 (Spec Correctness)**: Complete for all 7 contracts.
- **Layer 2 (ContractSpec -> IR)**: Per-function preservation theorems complete for all 7 contracts; contract-level dispatch generalization is underway (SimpleStorage + Counter + Owned done).
- **Layer 3 (IR -> Yul)**: In progress (core IR/Yul semantics aligned, runtime preservation theorem in place, smoke tests assert revert preservation across IR and Yul, and `YulGeneration/Equivalence.lean` now includes aligned-Yul helpers plus a `calldataload` (offset >= 4) evaluation lemma).

## Iterations

| Iteration | Contract | Core Change | Key Feature |
|-----------|----------|-------------|-------------|
| 1 | SimpleStorage | Bootstrap | `ContractState`, storage ops, `require` |
| 2 | Counter | Reuse | Read-modify-write pattern |
| 3 | Owned | Extend | Address storage, access control |
| 4 | OwnedCounter | Compose | Pattern composition |
| 5 | SafeCounter | Extend | Math stdlib with checked arithmetic |
| 6 | Ledger | Extend | Mapping support (`Address -> Uint256`) |
| 7 | SimpleToken | Compose | Combined patterns: owned + ledger + supply |

## Design Decisions

**What worked:**
- `Address := String`, `Uint256` is a dedicated 256-bit modular type.
- Storage as functions (`Nat -> Uint256`), not finite maps. Uninitialized slots return 0.
- `require` returns `ContractResult.revert msg s`, preserving original state.
- Manual storage slot allocation (slot 0, 1, 2...). No automatic allocation needed.
- `onlyOwner` is a regular function, not special syntax.

**What didn't work:**
- `StateM.get` doesn't exist in Lean 4. Use plain `get` in do-notation.
- `Repr` can't derive for function types. Added manual instance.
- Generic `requireSome` needs `[Inhabited a]`. Made Uint256-specific version instead.
- Marking `.fst`/`.snd` as `@[simp]` caused over-simplification. Added operation-specific simp lemmas.

## Arithmetic Semantics

All core arithmetic is EVM-compatible. `Uint256` wraps at `2^256`, so `+`, `-`, `*`, `/`, and `%` match EVM behavior by default.

Two approaches coexist for overflow safety:
- **Counter / Ledger / SimpleToken**: Bare `+`/`-` (modular arithmetic, EVM-accurate)
- **SafeCounter**: `safeAdd`/`safeSub` from `Stdlib/Math.lean` return `Option`, reverting on overflow/underflow

`MAX_UINT256 := 2^256 - 1`. Safe arithmetic checks this bound before returning `some`.

## Proof Techniques

**Full unfolding** is the main approach:
```lean
simp only [operation, onlyOwner, isOwner, owner,
  msgSender, getStorageAddr, setStorage,
  DumbContracts.bind, Bind.bind, Pure.pure,
  Contract.run, ContractResult.snd]
simp [h_owner]
```

Works because the EDSL is shallow: every contract function is a composition of core primitives.

**Private unfold helpers** pre-compute exact result states when guards pass:
```lean
private theorem increment_unfold (s : ContractState)
  (h_owner : s.sender = s.storageAddr 0) :
  (increment.run s) = ContractResult.success () { ... } := by
  simp only [increment, ...]; simp [h_owner]
```

But `private theorem` isn't accessible from other files. Isolation proofs in separate files must repeat the full unfolding.

**Other techniques:**
- **Boolean equality**: Use `beq_iff_eq` to convert `(x == y) = true` to `x = y`
- **Slot preservation**: `intro slot h_neq h_eq; exact absurd h_eq h_neq`
- **List sum reasoning**: `omega` can't handle `List.sum` or `var * var`. Use explicit `Nat.add_assoc`/`add_comm`/`add_left_comm` chains
- **No Mathlib**: `push_neg`, `set`, `ring`, `linarith` unavailable. Use `by_cases`, explicit witnesses, manual `Nat.*` lemma chains

## Verification Structure

Each contract has:
- `DumbContracts/Examples/X.lean` -- Implementation
- `DumbContracts/Specs/X/Spec.lean` -- Pre/postconditions for each operation
- `DumbContracts/Specs/X/Invariants.lean` -- State properties that should hold
- `DumbContracts/Specs/X/Proofs.lean` -- Layer 1: Spec correctness vs EDSL
- `DumbContracts/Proofs/X/Basic.lean` -- Spec conformance, basic properties
- `DumbContracts/Proofs/X/Correctness.lean` -- Revert proofs, composition, end-to-end

Some contracts have additional proof files:
- `DumbContracts/Proofs/SimpleToken/Supply.lean` -- Supply conservation equations
- `DumbContracts/Proofs/SimpleToken/Isolation.lean` -- Storage isolation across slot types
- `DumbContracts/Proofs/Ledger/Conservation.lean` -- Balance conservation equations
- `DumbContracts/Proofs/OwnedCounter/Isolation.lean` -- Cross-pattern storage isolation

Conservation proofs use `List.countOcc` to account for duplicate addresses. For `NoDup` lists, transfer preserves exact sum. For general lists, exact equations with `countOcc` multipliers are proven.

## Known Limitations

- **Self-transfer**: Modeled as a no-op; transfer theorems no longer require `sender != to`.
- **Supply = sum of balances**: Requires finite address model. Proven as exact sum equations with `countOcc`, not as global invariant over all addresses.
- **`ContractResult.fst`**: Returns `default` on revert, requiring `[Inhabited a]`. Proofs using `.fst` always show result is `success` first.
- **No events, no gas**: EDSL models storage and control flow only.
- **No nested mappings**: Can't express `mapping(address => mapping(address => uint256))` without extending core.

## Compiler Development

### Generic Compilation (Completed 2026-02-10)

**Problem**: Manual IR translation for each contract (unmaintainable and repetitive).

**Solution**: Declarative contract specification DSL with automatic IR generation.

**Result**: All 7 contracts compile automatically. Zero manual IR. Generated code is more optimized than manual translations.

**Implementation** (as of 2026-02-13):
- `Compiler/ContractSpec.lean` -- DSL + automatic IR compiler
  - Type-safe expression language (literals, storage, mappings, arithmetic, comparisons)
  - Statement DSL (setStorage, setMapping, require, return)
  - Automatic storage slot inference from field order
  - Constructor parameter handling (bytecode argument loading)
- `Compiler/Specs.lean` -- All 7 contract specifications
- `Compiler/Selector.lean` -- Function selector computation (Solidity keccak256)
- `Compiler/Main.lean` -- New compilation entry point

**Before**:
```lean
// Manual IR for each contract (long, repetitive)
private def ownedContract : IRContract :=
  let deployBody := [
    stmtLet "argsOffset" (call "sub" [call "codesize" [], lit 32]),
    stmtExpr (call "codecopy" [lit 0, ident "argsOffset", lit 32]),
    stmtLet "initialOwner" (call "and" [call "mload" [lit 0], hex addressMask]),
    sstoreSlot 0 (ident "initialOwner")
  ]
  // ... more manual Yul construction
```

**After**:
```lean
// Declarative spec (compact, declarative)
def ownedSpec : ContractSpec := {
  name := "Owned"
  fields := [{ name := "owner", ty := FieldType.address }]
  constructor := some {
    params := [{ name := "initialOwner", ty := ParamType.address }]
    body := [Stmt.setStorage "owner" (Expr.constructorArg 0)]
  }
  functions := [/* ... high-level DSL */]
}
```

**Metrics**:
- Manual IR eliminated in favor of generated IR from the spec
- Time to add contract dropped significantly in practice
- Test results: Foundry and Lean proofs pass in CI (see CI logs for current counts)
- Code quality: More concise, optimized (expression inlining)

**Features Achieved**:
- [x] Automatic storage slot inference
- [x] Constructor parameter support
- [x] Function selector management
- [x] Type-safe DSL prevents errors
- [x] Code optimization

**Usage**:
```bash
lake build dumbcontracts-compiler    # Build compiler
lake exe dumbcontracts-compiler      # Generate all contracts
forge test  # Run unit, property, and differential tests
```

### Differential Testing (Completed 2026-02-10)

**Problem**: No way to trust compiler correctness without formal proofs. Need high confidence that compiled EVM matches verified EDSL semantics.

**Solution**: Random transaction generation + parallel execution on EDSL interpreter and compiled EVM bytecode.

**Result**: default runs use 100 random transactions per contract, while CI scales the large suite to 10,000+ per contract. Zero mismatches detected so far.

**Implementation** (as of 2026-02-13):
- `Compiler/Interpreter.lean` -- EDSL interpreter for differential testing
  - Executes EDSL contracts on abstract state
  - Returns JSON results for comparison with EVM
  - Supports all 7 contracts used in the Foundry differential suites
- `Compiler/RandomGen.lean` -- Random transaction generator
  - Generates random addresses, values, and function calls
  - Contract-specific transaction generation (store/retrieve for SimpleStorage)
- `test/DiffTestConfig.sol` -- Shared sharding + seed configuration
  - Centralizes shard range calculation and per-shard seed mixing
  - Exposes `_diffRandomSmallConfig()`/`_diffRandomLargeConfig()` so each harness opts into the same knobs
- `test/DifferentialSimpleStorage.t.sol` -- Foundry test harness
  - Executes transactions on compiled EVM bytecode
  - Calls EDSL interpreter via `vm.ffi`
  - Compares: success/revert, return values, storage changes
  - Tracks independent state for EVM and EDSL

**Critical Fixes** (Bugbot second review):
1. **EDSL State Independence**: Fixed bug where EVM results were fed back to EDSL state tracker, making tests always match. Added JSON parsing to maintain separate EDSL and EVM state.
2. **Test Assertions**: Added `assertTrue` checks to prevent silent test failures.
3. **Underflow Guards**: Added length guards to JSON parsing to prevent underflow reverts.
4. **Clang Crash**: Removed `deriving Repr` to fix CI compilation crash (Lean generated overly complex C code).
5. **Mapping Change De-duplication**: Mapping change keys are de-duplicated before comparison to avoid self-transfer double counting and reduce diff output size.

**Test Results**:
- 100/100 random transactions pass per contract in default runs
- 10,000+ random transactions pass per contract in CI (large suite)
- Large suite is sharded across 8 CI jobs to stay within per-test gas limits
- Zero mismatches detected
- Last verified (2026-02-13): 264/264 Foundry tests passing
- CI: check GitHub Actions for current status

**Usage**:
```bash
lake build Compiler.Interpreter           # Build interpreter
lake exe difftest-interpreter simpleStorage store 0 100  # Run single tx
forge test --match-contract Differential  # Run default (100) random tests
# Scale the large suite (used in CI):
DIFFTEST_RANDOM_LARGE=10000 forge test --match-contract Differential
# Shard the large suite (CI uses 8 shards):
DIFFTEST_SHARD_COUNT=8 DIFFTEST_SHARD_INDEX=0 DIFFTEST_RANDOM_LARGE=10000 \
  forge test --match-contract Differential
```

**Structured Next Steps (A-G)**:

**A. Finish Layer 2 (ContractSpec -> IR)**:
- [x] SimpleStorage + Counter preservation proofs are pinned and compiling.
- [x] Generalized preservation proofs now cover Owned, OwnedCounter, SafeCounter, Ledger, and SimpleToken.
- [x] Conversion relations for mappings + address types are exercised in the full suite of Layer 2 proofs.
- [x] Removed the exploratory `StoreProofAttempt.lean` once the real proof path was in place.
- [x] Contract-level dispatch preservation exists for SimpleStorage + Counter + Owned + SafeCounter + OwnedCounter.
- [x] Ledger + SimpleToken dispatch theorems are now proven.
- **Done when**: each contract has a contract-level dispatch theorem that composes per-function proofs.

**B. Finish Layer 3 (IR -> Yul)**:
- Prove IR op -> Yul op equivalence for all IR instructions, not just the high-level theorem statement.
- Add contract-level end-to-end theorems akin to Layer 2: "interpretIR = interpretYulFromIR" per contract.
- **Done when**: every IR instruction has a corresponding Lean equivalence lemma in `Compiler/Proofs/YulGeneration/Equivalence.lean`, each contract has a compiled end-to-end theorem, and the layer builds without TODOs or `admit`s in the Yul generation proofs.

**C. Scale Differential Testing**:
- [x] Centralize the "random run" entrypoint so each harness can opt into the same seed/count knobs (avoid copy-paste and drift).
- [x] Increase transaction counts from 100 to 10,000+ per contract (keep a quick-run default, allow override for CI).
- [x] Add adversarial patterns: self-transfer (done), max uint values (done for SimpleStorage/Ledger/SimpleToken), boundary overflows.
- **Done when**: CI runs a 10,000+ tx suite per contract, and the random harness setup is shared and parameterized across all 7 contracts (met).

**D. Property Extraction (Proofs -> Tests)**:
- Extract statements from Layer 1 proofs and compile them into Foundry invariants.
- Guard the manifest against drift: keep `test/property_manifest.json` synchronized with proofs via `scripts/check_property_manifest_sync.py`.
  - Start with SimpleStorage: extract 3-5 invariants and wire them end-to-end to validate the pipeline before scaling.
  - Create a small "invariant catalog" per contract (plain English + Lean lemma name).
  - Add matching `test/Invariant<Contract>.t.sol` suites that enforce each invariant.
  - Ensure invariants run against both the Lean interpreter and the compiled Yul (differential style).
- **Done when**: every Layer 1 proof has a corresponding Foundry invariant and all invariants pass in CI.

**E. Address Known Limitations (Core Modeling)**:
- Self-transfer semantics: modeled as a no-op in token/ledger specs. (Done)
- Full supply = sum of balances in a finite address model.
  - Introduce a finite address set parameter so proofs can quantify over balances.
- Nested mappings (needed for allowances / ERC20 approve).
  - Extend the storage model to support `Address -> Address -> Uint256` with clean read/write lemmas.
- **Done when**: an ERC-20-style spec can express `approve`/`transferFrom`, self-transfer is defined, and a supply-equals-sum proof composes over the finite address set.

**F. Reduce Remaining Trust Assumptions**:
- [x] Add a keccak256 verification step so selectors don't stay "trusted".
  - Cross-check selector hashing against `cast` in `scripts/check_selectors.py`.
  - Validate IR selector tables and Yul switch cases against specs in CI.
  - **Done when**: selector hashes are proven or cross-checked against a trusted toolchain (met).
- Add a formalized "bridge" lemma between Yul semantics and EVM, or document the test/verification gap clearly.
  - **Current gap**: Yul correctness is proven against the Lean Yul interpreter, but the Lean Yul interpreter is not yet proven equivalent to EVM execution.
  - **Mitigation today**: Foundry tests provide behavioral confidence, but they do not close the formal gap.
  - **Completion criterion**: a proof (or mechanized model) that links Yul execution to EVM execution for the supported subset.

**G. Documentation (Optional But Valuable)**:
- Add a concise "How to add a new contract" guide (Spec -> EDSL -> Proof -> Compiler spec -> Tests).
  - 1-page checklist anchored to SimpleStorage as the minimal example:
    - `DumbContracts/Specs/SimpleStorage.lean`
    - `DumbContracts/Examples/SimpleStorage.lean`
    - `DumbContracts/Specs/SimpleStorage/Proofs.lean`
    - `Compiler/Proofs/IRGeneration/SimpleStorageProof.lean`
    - `test/DifferentialSimpleStorage.t.sol`
  - Template section that shows the expected file layout + naming conventions.
  - Short "common pitfalls" callout (e.g., storage slot mismatches, mapping conversions).
- **Done when**: a newcomer can follow the guide to add a toy contract end-to-end in under 30 minutes.
- Keep this page as the single source of truth for progress and new milestones.

**Trust Model**: 100 random tests provide probabilistic confidence. Formal verification (Item 4) would provide mathematical certainty.

### Future: Property Extraction & Compiler Verification

**Property Extraction** (Roadmap Item 3):
- Parse 252 proven theorems from EDSL files
- Generate Foundry property tests from theorem statements
- Example: `transfer_total_supply` theorem -> Foundry invariant test
- Result: 252 theorems verified in both proofs and on-chain tests

**Compiler Verification** (Roadmap Item 4, long-term):
- Formalize EVM execution in Lean
- Prove: `forall contract state tx, evm_exec (compile contract) state tx = edsl_exec contract state tx`
- Eliminates all trust assumptions in the compilation pipeline

## What Could Come Next

See **Structured Next Steps (A-G)** above for the single source of truth. The older "next steps" list has been removed to avoid drift and duplication.

## Detailed Logs

For iteration-by-iteration development notes, see [/research/iterations](/research/iterations).
