---
title: Research & Development
description: Design decisions, iterations, and proof techniques
---

# Research & Development

**Compact core, built across 7 iterations. Zero sorry, zero axioms.**

## Evolution

The project evolved in two phases:

**Phase 1 (Iterations 1-7)**: Built 7 contracts on `StateM ContractState`. The core stayed intentionally small while storage types were added incrementally: `Nat -> Uint256` (iteration 1), `Nat -> Address` (iteration 3), `Nat -> Address -> Uint256` for mappings (iteration 6). Each addition was driven by a concrete example that needed it.

**Phase 2 (Verification)**: Replaced `StateM` with custom `ContractResult` type (`success | revert`) to model `require` guards explicitly. This enabled proving properties like "mint reverts when caller is not owner." The core expanded to include proof automation lemmas and EVM context fields.

## Progress and Roadmap (as of 2026-02-13)

This is the single source of truth for progress, roadmap, and milestone updates.

- **Layer 1 (Spec Correctness)**: Complete for all 7 contracts.
- **Layer 2 (ContractSpec → IR)**: Infrastructure complete; proofs in progress.
- **Layer 3 (IR → Yul)**: Not started.

## Iterations

| Iteration | Contract | Core Change | Key Feature |
|-----------|----------|-------------|-------------|
| 1 | SimpleStorage | Bootstrap | `ContractState`, storage ops, `require` |
| 2 | Counter | Reuse | Read-modify-write pattern |
| 3 | Owned | Extend | Address storage, access control |
| 4 | OwnedCounter | Compose | Pattern composition |
| 5 | SafeCounter | Extend | Math stdlib with checked arithmetic |
| 6 | Ledger | Extend | Mapping support (`Address -> Uint256`) |
| 7 | SimpleToken | Compose | Combined patterns: owned + ledger + supply |

## Design Decisions

**What worked:**
- `Address := String`, `Uint256` is a dedicated 256-bit modular type.
- Storage as functions (`Nat -> Uint256`), not finite maps. Uninitialized slots return 0.
- `require` returns `ContractResult.revert msg s`, preserving original state.
- Manual storage slot allocation (slot 0, 1, 2...). No automatic allocation needed.
- `onlyOwner` is a regular function, not special syntax.

**What didn't work:**
- `StateM.get` doesn't exist in Lean 4. Use plain `get` in do-notation.
- `Repr` can't derive for function types. Added manual instance.
- Generic `requireSome` needs `[Inhabited a]`. Made Uint256-specific version instead.
- Marking `.fst`/`.snd` as `@[simp]` caused over-simplification. Added operation-specific simp lemmas.

## Arithmetic Semantics

All core arithmetic is EVM‑compatible. `Uint256` wraps at `2^256`, so `+`, `-`, `*`, `/`, and `%` match EVM behavior by default.

Two approaches coexist for overflow safety:
- **Counter / Ledger / SimpleToken**: Bare `+`/`-` (modular arithmetic, EVM‑accurate)
- **SafeCounter**: `safeAdd`/`safeSub` from `Stdlib/Math.lean` return `Option`, reverting on overflow/underflow

`MAX_UINT256 := 2^256 - 1`. Safe arithmetic checks this bound before returning `some`.

## Proof Techniques

**Full unfolding** is the main approach:
```lean
simp only [operation, onlyOwner, isOwner, owner,
  msgSender, getStorageAddr, setStorage,
  DumbContracts.bind, Bind.bind, Pure.pure,
  Contract.run, ContractResult.snd]
simp [h_owner]
```

Works because the EDSL is shallow: every contract function is a composition of core primitives.

**Private unfold helpers** pre-compute exact result states when guards pass:
```lean
private theorem increment_unfold (s : ContractState)
  (h_owner : s.sender = s.storageAddr 0) :
  (increment.run s) = ContractResult.success () { ... } := by
  simp only [increment, ...]; simp [h_owner]
```

But `private theorem` isn't accessible from other files. Isolation proofs in separate files must repeat the full unfolding.

**Other techniques:**
- **Boolean equality**: Use `beq_iff_eq` to convert `(x == y) = true` to `x = y`
- **Slot preservation**: `intro slot h_neq h_eq; exact absurd h_eq h_neq`
- **List sum reasoning**: `omega` can't handle `List.sum` or `var * var`. Use explicit `Nat.add_assoc`/`add_comm`/`add_left_comm` chains
- **No Mathlib**: `push_neg`, `set`, `ring`, `linarith` unavailable. Use `by_cases`, explicit witnesses, manual `Nat.*` lemma chains

## Verification Structure

Each contract has:
- `DumbContracts/Examples/X.lean` — Implementation
- `DumbContracts/Specs/X/Spec.lean` — Pre/postconditions for each operation
- `DumbContracts/Specs/X/Invariants.lean` — State properties that should hold
- `DumbContracts/Specs/X/Proofs.lean` — Layer 1: Spec correctness vs EDSL
- `DumbContracts/Proofs/X/Basic.lean` — Spec conformance, basic properties
- `DumbContracts/Proofs/X/Correctness.lean` — Revert proofs, composition, end-to-end

Some contracts have additional proof files:
- `DumbContracts/Proofs/SimpleToken/Supply.lean` — Supply conservation equations
- `DumbContracts/Proofs/SimpleToken/Isolation.lean` — Storage isolation across slot types
- `DumbContracts/Proofs/Ledger/Conservation.lean` — Balance conservation equations
- `DumbContracts/Proofs/OwnedCounter/Isolation.lean` — Cross-pattern storage isolation

Conservation proofs use `List.countOcc` to account for duplicate addresses. For `NoDup` lists, transfer preserves exact sum. For general lists, exact equations with `countOcc` multipliers are proven.

## Known Limitations

- **Self-transfer**: Transfer theorems require `sender != to`. Self-transfer overwrites sender's deduction with recipient's addition. Could be modeled as identity operation.
- **Supply = sum of balances**: Requires finite address model. Proven as exact sum equations with `countOcc`, not as global invariant over all addresses.
- **`ContractResult.fst`**: Returns `default` on revert, requiring `[Inhabited a]`. Proofs using `.fst` always show result is `success` first.
- **No events, no gas**: EDSL models storage and control flow only.
- **No nested mappings**: Can't express `mapping(address => mapping(address => uint256))` without extending core.

## Compiler Development

### Generic Compilation (Completed 2026-02-10)

**Problem**: Manual IR translation for each contract (unmaintainable and repetitive).

**Solution**: Declarative contract specification DSL with automatic IR generation.

**Result**: All 7 contracts compile automatically. Zero manual IR. Generated code is more optimized than manual translations.

**Implementation** (as of 2026-02-13):
- `Compiler/ContractSpec.lean` — DSL + automatic IR compiler
  - Type-safe expression language (literals, storage, mappings, arithmetic, comparisons)
  - Statement DSL (setStorage, setMapping, require, return)
  - Automatic storage slot inference from field order
  - Constructor parameter handling (bytecode argument loading)
- `Compiler/Specs.lean` — All 7 contract specifications
- `Compiler/Selector.lean` — Function selector computation (Solidity keccak256)
- `Compiler/Main.lean` — New compilation entry point

**Before**:
```lean
// Manual IR for each contract (long, repetitive)
private def ownedContract : IRContract :=
  let deployBody := [
    stmtLet "argsOffset" (call "sub" [call "codesize" [], lit 32]),
    stmtExpr (call "codecopy" [lit 0, ident "argsOffset", lit 32]),
    stmtLet "initialOwner" (call "and" [call "mload" [lit 0], hex addressMask]),
    sstoreSlot 0 (ident "initialOwner")
  ]
  // ... more manual Yul construction
```

**After**:
```lean
// Declarative spec (compact, declarative)
def ownedSpec : ContractSpec := {
  name := "Owned"
  fields := [{ name := "owner", ty := FieldType.address }]
  constructor := some {
    params := [{ name := "initialOwner", ty := ParamType.address }]
    body := [Stmt.setStorage "owner" (Expr.constructorArg 0)]
  }
  functions := [/* ... high-level DSL */]
}
```

**Metrics**:
- Manual IR eliminated in favor of generated IR from the spec
- Time to add contract dropped significantly in practice
- Test results: Foundry tests pass (264/264 as of 2026-02-13), Lean proofs verify (252/252 as of 2026-02-13)
- Code quality: More concise, optimized (expression inlining)

**Features Achieved**:
- ✅ Automatic storage slot inference
- ✅ Constructor parameter support
- ✅ Function selector management
- ✅ Type-safe DSL prevents errors
- ✅ Code optimization

**Usage**:
```bash
lake build dumbcontracts-compiler    # Build compiler
lake exe dumbcontracts-compiler      # Generate all contracts
forge test  # 264/264 tests pass (as of 2026-02-13)
```

### Differential Testing (Completed 2026-02-10)

**Problem**: No way to trust compiler correctness without formal proofs. Need high confidence that compiled EVM matches verified EDSL semantics.

**Solution**: Random transaction generation + parallel execution on EDSL interpreter and compiled EVM bytecode.

**Result**: 100 random transactions pass for SimpleStorage contract. Zero mismatches detected. Ready to scale to all contracts.

**Implementation** (as of 2026-02-13):
- `Compiler/Interpreter.lean` — EDSL interpreter for differential testing
  - Executes EDSL contracts on abstract state
  - Returns JSON results for comparison with EVM
  - Supports SimpleStorage and Counter (extensible to all contracts)
- `Compiler/RandomGen.lean` — Random transaction generator
  - Generates random addresses, values, and function calls
  - Contract-specific transaction generation (store/retrieve for SimpleStorage)
- `test/DifferentialSimpleStorage.t.sol` — Foundry test harness
  - Executes transactions on compiled EVM bytecode
  - Calls EDSL interpreter via `vm.ffi`
  - Compares: success/revert, return values, storage changes
  - Tracks independent state for EVM and EDSL

**Critical Fixes** (Bugbot second review):
1. **EDSL State Independence**: Fixed bug where EVM results were fed back to EDSL state tracker, making tests always match. Added JSON parsing to maintain separate EDSL and EVM state.
2. **Test Assertions**: Added `assertTrue` checks to prevent silent test failures.
3. **Underflow Guards**: Added length guards to JSON parsing to prevent underflow reverts.
4. **Clang Crash**: Removed `deriving Repr` to fix CI compilation crash (Lean generated overly complex C code).

**Test Results**:
- 100/100 random transactions pass (SimpleStorage)
- Zero mismatches detected
- All Foundry tests passing (264/264 as of 2026-02-13)
- CI: All checks passing

**Usage**:
```bash
lake build Compiler.Interpreter           # Build interpreter
lake exe difftest-interpreter simpleStorage store 0 100  # Run single tx
forge test --match-contract Differential  # Run 100 random tests
```

**Next Steps**:
- See the structured roadmap below (A–G), which consolidates all upcoming work into one list.

**Structured Next Steps (A–G)**:

**A. Finish Layer 2 (ContractSpec → IR)**:
- Generalize the SimpleStorage preservation proof to all 7 contracts (SimpleStorage, Counter, Owned, OwnedCounter, SafeCounter, Ledger, SimpleToken).
- Formalize the conversion relation across types (SpecStorage ↔ IRState) for mappings and address types, not just simple storage slots.
- Turn the “attempt” file into a real proof path or remove it once the general proof is in place.
- Use `Compiler/Proofs/IRGeneration/SimpleStorageProof.lean` as the template: replicate the structure, swap in each contract’s state relation, and end with a per-contract preservation lemma.
- **Done when**: each contract has a Layer 2 preservation theorem that compiles in Lean and `Compiler/Proofs/IRGeneration/StoreProofAttempt.lean` is either replaced by the real proof path or deleted.

**B. Finish Layer 3 (IR → Yul)**:
- Prove IR op → Yul op equivalence for all IR instructions, not just the high-level theorem statement.
- Add contract-level end-to-end theorems akin to Layer 2: “interpretIR = interpretYulFromIR” per contract.
- **Done when**: every IR instruction has a corresponding Lean equivalence lemma in `Compiler/Proofs/YulGeneration/Equivalence.lean`, each contract has a compiled end-to-end theorem, and the layer builds without TODOs or `admit`s in the Yul generation proofs.

**C. Scale Differential Testing**:
- Add diff-testing harnesses for all 7 contracts.
  - Extend `Compiler/RandomGen.lean` with a transaction generator per contract.
  - Add a `test/Differential<Contract>.t.sol` harness that calls `difftest-interpreter` for that contract.
- Increase transaction counts from 100 to 10,000+ per contract (keep a quick-run default, allow override for CI). 
- Add adversarial patterns: self-transfer, max uint values, boundary overflows.
- **Done when**: each contract has a generator + harness, and a 10,000+ tx run passes in CI.

**D. Property Extraction (Proofs → Tests)**:
- Extract statements from Layer 1 proofs and compile them into Foundry invariants.
  - Start with SimpleStorage: extract 3–5 invariants and wire them end-to-end to validate the pipeline before scaling.
  - Create a small “invariant catalog” per contract (plain English + Lean lemma name).
  - Add matching `test/Invariant<Contract>.t.sol` suites that enforce each invariant.
  - Ensure invariants run against both the Lean interpreter and the compiled Yul (differential style).
- **Done when**: every Layer 1 proof has a corresponding Foundry invariant and all invariants pass in CI.

**E. Address Known Limitations (Core Modeling)**:
- Self-transfer semantics: add a precise rule or identity behavior in token/ledger specs.
  - Decide if `transfer(a, a, x)` is a no-op or a guarded subtraction+addition, and state it explicitly.
- Full supply = sum of balances in a finite address model.
  - Introduce a finite address set parameter so proofs can quantify over balances.
- Nested mappings (needed for allowances / ERC20 approve).
  - Extend the storage model to support `Address -> Address -> Uint256` with clean read/write lemmas.
- **Done when**: an ERC‑20-style spec can express `approve`/`transferFrom`, self-transfer is defined, and a supply‑equals‑sum proof composes over the finite address set.

**F. Reduce Remaining Trust Assumptions**:
- Add a keccak256 verification step so selectors don’t stay “trusted”.
  - Compute selectors in Lean from the Solidity signature and prove they match the generated selector in `Compiler/Selector.lean`.
  - Add a small fixture-based test (Solidity/Yul) to guard the hash implementation against drift.
  - **Done when**: selector hashes are proven in Lean and a fixture test asserts at least 3 real-world signatures match Solidity compiler output.
- Add a formalized “bridge” lemma between Yul semantics and EVM, or document the test/verification gap clearly.
  - **Current gap**: Yul correctness is proven against the Lean Yul interpreter, but the Lean Yul interpreter is not yet proven equivalent to EVM execution.
  - **Mitigation today**: Foundry tests provide behavioral confidence, but they do not close the formal gap.
  - **Completion criterion**: a proof (or mechanized model) that links Yul execution to EVM execution for the supported subset.

**G. Documentation (Optional But Valuable)**:
- Add a concise “How to add a new contract” guide (Spec → EDSL → Proof → Compiler spec → Tests).
  - 1-page checklist anchored to SimpleStorage as the minimal example:
    - `DumbContracts/Specs/SimpleStorage.lean`
    - `DumbContracts/Examples/SimpleStorage.lean`
    - `DumbContracts/Specs/SimpleStorage/Proofs.lean`
    - `Compiler/Proofs/IRGeneration/SimpleStorageProof.lean`
    - `test/DifferentialSimpleStorage.t.sol`
  - Template section that shows the expected file layout + naming conventions.
  - Short “common pitfalls” callout (e.g., storage slot mismatches, mapping conversions).
- **Done when**: a newcomer can follow the guide to add a toy contract end-to-end in <30 minutes.
- Keep this page as the single source of truth for progress and new milestones.

**Trust Model**: 100 random tests provide probabilistic confidence. Formal verification (Item 4) would provide mathematical certainty.

### Future: Property Extraction & Compiler Verification

**Property Extraction** (Roadmap Item 3):
- Parse 252 proven theorems from EDSL files
- Generate Foundry property tests from theorem statements
- Example: `transfer_total_supply` theorem → Foundry invariant test
- Result: 252 theorems verified in both proofs and on-chain tests

**Compiler Verification** (Roadmap Item 4, long-term):
- Formalize EVM execution in Lean
- Prove: `∀ contract state tx, evm_exec (compile contract) state tx = edsl_exec contract state tx`
- Eliminates all trust assumptions in the compilation pipeline

## What Could Come Next

1. ~~Differential testing (70k+ random tests)~~ ✅ **Completed** (100 tests for SimpleStorage, ready to scale)
2. Scale differential testing to all 7 contracts (70k+ total tests)
3. Property extraction (252 theorems → Foundry tests) — Roadmap Item 3
4. Compiler verification (formal correctness proof) — Roadmap Item 4
5. Self-transfer handling (special-case or identity operation)
6. Full `supply = sum(balances)` with finite address set
7. ERC-20 allowances (needs `Address -> Address -> Uint256` storage)
8. Gas consumption tracking in `ContractResult`
9. Cross-contract call modeling

## Detailed Logs

For iteration-by-iteration development notes, see [/research/iterations](/research/iterations).
