---
title: Research & Development
description: Design decisions, iterations, and proof techniques
---

# Research & Development

**212-line core, built across 7 iterations. Zero sorry, zero axioms.**

## Evolution

The project evolved in two phases:

**Phase 1 (Iterations 1-7)**: Built 7 contracts on `StateM ContractState`. Core grew from 58 to 82 lines. Storage types were added incrementally: `Nat -> Uint256` (iteration 1), `Nat -> Address` (iteration 3), `Nat -> Address -> Uint256` for mappings (iteration 6). Each addition was driven by a concrete example that needed it.

**Phase 2 (Verification)**: Replaced `StateM` with custom `ContractResult` type (`success | revert`) to model `require` guards explicitly. This enabled proving properties like "mint reverts when caller is not owner." Core grew to 212 lines, mostly from simp lemmas for proof automation.

## Iterations

| Iteration | Contract | Lines Added | Key Feature |
|-----------|----------|-------------|-------------|
| 1 | SimpleStorage | 58 | Bootstrap: `ContractState`, storage ops, `require` |
| 2 | Counter | 0 | Read-modify-write pattern |
| 3 | Owned | +14 | Address storage, access control |
| 4 | OwnedCounter | 0 | Pattern composition |
| 5 | SafeCounter | 0 | Math stdlib with checked arithmetic |
| 6 | Ledger | +13 | Mapping support (`Address -> Uint256`) |
| 7 | SimpleToken | 0 | Combined patterns: owned + ledger + supply |

Core: 58 → 72 → 82 lines (phase 1), then 82 → 212 lines (phase 2 with verification).

## Design Decisions

**What worked:**
- `Address := String`, `Uint256 := Nat`. Simpler than bounded types.
- Storage as functions (`Nat -> Uint256`), not finite maps. Uninitialized slots return 0.
- `require` returns `ContractResult.revert msg s`, preserving original state.
- Manual storage slot allocation (slot 0, 1, 2...). No automatic allocation needed.
- `onlyOwner` is a regular function, not special syntax.

**What didn't work:**
- `StateM.get` doesn't exist in Lean 4. Use plain `get` in do-notation.
- `Repr` can't derive for function types. Added manual instance.
- Generic `requireSome` needs `[Inhabited a]`. Made Uint256-specific version instead.
- Marking `.fst`/`.snd` as `@[simp]` caused over-simplification. Added operation-specific simp lemmas.

## Arithmetic Semantics

Lean `Nat` subtraction saturates (5 - 10 = 0). Solidity 0.8+ reverts. These are different.

Solution: Two approaches coexist.
- **Counter**: Bare `+`/`-` (Lean Nat semantics, fast, proven safe for increment/decrement from zero)
- **SafeCounter**: `safeAdd`/`safeSub` from `Stdlib/Math.lean` return `Option`, revert on overflow/underflow

`MAX_UINT256 := 2^256 - 1`. Safe arithmetic checks this bound.

## Proof Techniques

**Full unfolding** is the main approach:
```lean
simp only [operation, onlyOwner, isOwner, owner,
  msgSender, getStorageAddr, setStorage,
  DumbContracts.bind, Bind.bind, Pure.pure,
  Contract.run, ContractResult.snd]
simp [h_owner]
```

Works because the EDSL is shallow: every contract function is a composition of core primitives.

**Private unfold helpers** pre-compute exact result states when guards pass:
```lean
private theorem increment_unfold (s : ContractState)
  (h_owner : s.sender = s.storageAddr 0) :
  (increment.run s) = ContractResult.success () { ... } := by
  simp only [increment, ...]; simp [h_owner]
```

But `private theorem` isn't accessible from other files. Isolation proofs in separate files must repeat the full unfolding.

**Other techniques:**
- **Boolean equality**: Use `beq_iff_eq` to convert `(x == y) = true` to `x = y`
- **Slot preservation**: `intro slot h_neq h_eq; exact absurd h_eq h_neq`
- **List sum reasoning**: `omega` can't handle `List.sum` or `var * var`. Use explicit `Nat.add_assoc`/`add_comm`/`add_left_comm` chains
- **No Mathlib**: `push_neg`, `set`, `ring`, `linarith` unavailable. Use `by_cases`, explicit witnesses, manual `Nat.*` lemma chains

## Verification Structure

Each contract has:
- `Examples/X.lean` — Implementation
- `Specs/X/Spec.lean` — Pre/postconditions for each operation
- `Specs/X/Invariants.lean` — State properties that should hold
- `Proofs/X/Basic.lean` — Spec conformance, basic properties
- `Proofs/X/Correctness.lean` — Revert proofs, composition, end-to-end

Some contracts have additional proof files:
- `SimpleToken/Supply.lean` — Supply conservation equations
- `SimpleToken/Isolation.lean` — Storage isolation across slot types
- `Ledger/Conservation.lean` — Balance conservation equations
- `OwnedCounter/Isolation.lean` — Cross-pattern storage isolation

Conservation proofs use `List.countOcc` to account for duplicate addresses. For `NoDup` lists, transfer preserves exact sum. For general lists, exact equations with `countOcc` multipliers are proven.

## Known Limitations

- **Self-transfer**: Transfer theorems require `sender != to`. Self-transfer overwrites sender's deduction with recipient's addition. Could be modeled as identity operation.
- **Supply = sum of balances**: Requires finite address model. Proven as exact sum equations with `countOcc`, not as global invariant over all addresses.
- **`ContractResult.fst`**: Returns `default` on revert, requiring `[Inhabited a]`. Proofs using `.fst` always show result is `success` first.
- **No events, no gas**: EDSL models storage and control flow only.
- **No nested mappings**: Can't express `mapping(address => mapping(address => uint256))` without extending core.

## What Could Come Next

1. Self-transfer handling (special-case or identity operation)
2. Full `supply = sum(balances)` with finite address set
3. ERC-20 allowances (needs `Address -> Address -> Uint256` storage)
4. Gas consumption tracking in `ContractResult`
5. Cross-contract call modeling

## Detailed Logs

For iteration-by-iteration development notes, see [/research/iterations](/research/iterations).
