---
title: Research & Development
description: Design decisions, iterations, and proof techniques
---

# Research & Development

**Compact core, built across 7 iterations. 296 theorems, 5 documented axioms, 10 sorry remaining in Ledger sum proofs.**

## Evolution

The project evolved in two phases:

**Phase 1 (Iterations 1-7)**: Built 7 contracts on `StateM ContractState`. The core stayed intentionally small while storage types were added incrementally: `Nat -> Uint256` (iteration 1), `Nat -> Address` (iteration 3), `Nat -> Address -> Uint256` for mappings (iteration 6). Each addition was driven by a concrete example that needed it.

**Phase 2 (Verification)**: Replaced `StateM` with custom `ContractResult` type (`success | revert`) to model `require` guards explicitly. This enabled proving properties like "mint reverts when caller is not owner." The core expanded to include proof automation lemmas and EVM context fields.

## Progress and Roadmap (as of 2026-02-14)

This is the single source of truth for progress, roadmap, and milestone updates.

- **Layer 1 (Spec Correctness)**: Complete for all 7 contracts.
- **Layer 2 (ContractSpec → IR)**: Complete for all 7 contracts (per‑function preservation theorems compiled in Lean).
- **Layer 3 (IR → Yul)**: Complete — all 8 statement equivalence proofs + universal dispatcher proven (PR #42).

Recent updates:
- Layer 3 fully proven — all 8 statement equivalence proofs + universal dispatcher (PR #42).
- Function selectors verified via keccak256 axiom + CI validation (PR #43, #46).
- External cryptographic library linking support (PR #49).
- Nested mapping encoding preserves tagged base slots so nested slots round‑trip without losing tags.

## Iterations

| Iteration | Contract | Core Change | Key Feature |
|-----------|----------|-------------|-------------|
| 1 | SimpleStorage | Bootstrap | `ContractState`, storage ops, `require` |
| 2 | Counter | Reuse | Read-modify-write pattern |
| 3 | Owned | Extend | Address storage, access control |
| 4 | OwnedCounter | Compose | Pattern composition |
| 5 | SafeCounter | Extend | Math stdlib with checked arithmetic |
| 6 | Ledger | Extend | Mapping support (`Address -> Uint256`) |
| 7 | SimpleToken | Compose | Combined patterns: owned + ledger + supply |

## Design Decisions

**What worked:**
- `Address := String`, `Uint256` is a dedicated 256-bit modular type.
- Storage as functions (`Nat -> Uint256`), not finite maps. Uninitialized slots return 0.
- `require` returns `ContractResult.revert msg s`, preserving original state.
- Manual storage slot allocation (slot 0, 1, 2...). No automatic allocation needed.
- Selector maps remain explicit per contract (no ContractSpec-derived builder yet).
- `onlyOwner` is a regular function, not special syntax.

**What didn't work:**
- `StateM.get` doesn't exist in Lean 4. Use plain `get` in do-notation.
- `Repr` can't derive for function types. Added manual instance.
- Generic `requireSome` needs `[Inhabited a]`. Made Uint256-specific version instead.
- Marking `.fst`/`.snd` as `@[simp]` caused over-simplification. Added operation-specific simp lemmas.

## Arithmetic Semantics

All core arithmetic is EVM‑compatible. `Uint256` wraps at `2^256`, so `+`, `-`, `*`, `/`, and `%` match EVM behavior by default.

Two approaches coexist for overflow safety:
- **Counter / Ledger / SimpleToken**: Bare `+`/`-` (modular arithmetic, EVM‑accurate)
- **SafeCounter**: `safeAdd`/`safeSub` from `Stdlib/Math.lean` return `Option`, reverting on overflow/underflow

`MAX_UINT256 := 2^256 - 1`. Safe arithmetic checks this bound before returning `some`.

## Proof Techniques

**Full unfolding** is the main approach:
```lean
simp only [operation, onlyOwner, isOwner, owner,
  msgSender, getStorageAddr, setStorage,
  Verity.bind, Bind.bind, Pure.pure,
  Contract.run, ContractResult.snd]
simp [h_owner]
```

Works because the EDSL is shallow: every contract function is a composition of core primitives.

**Private unfold helpers** pre-compute exact result states when guards pass:
```lean
private theorem increment_unfold (s : ContractState)
  (h_owner : s.sender = s.storageAddr 0) :
  (increment.run s) = ContractResult.success () { ... } := by
  simp only [increment, ...]; simp [h_owner]
```

But `private theorem` isn't accessible from other files. Isolation proofs in separate files must repeat the full unfolding.

**Other techniques:**
- **Boolean equality**: Use `beq_iff_eq` to convert `(x == y) = true` to `x = y`
- **Slot preservation**: `intro slot h_neq h_eq; exact absurd h_eq h_neq`
- **List sum reasoning**: `omega` can't handle `List.sum` or `var * var`. Use explicit `Nat.add_assoc`/`add_comm`/`add_left_comm` chains
- **No Mathlib**: `push_neg`, `set`, `ring`, `linarith` unavailable. Use `by_cases`, explicit witnesses, manual `Nat.*` lemma chains

## Verification Structure

Each contract has:
- `Verity/Examples/X.lean` — Implementation
- `Verity/Specs/X/Spec.lean` — Pre/postconditions for each operation
- `Verity/Specs/X/Invariants.lean` — State properties that should hold
- `Verity/Specs/X/Proofs.lean` — Layer 1: Spec correctness vs EDSL
- `Verity/Proofs/X/Basic.lean` — Spec conformance, basic properties
- `Verity/Proofs/X/Correctness.lean` — Revert proofs, composition, end-to-end

Some contracts have additional proof files:
- `Verity/Proofs/SimpleToken/Supply.lean` — Supply conservation equations
- `Verity/Proofs/SimpleToken/Isolation.lean` — Storage isolation across slot types
- `Verity/Proofs/Ledger/Conservation.lean` — Balance conservation equations
- `Verity/Proofs/OwnedCounter/Isolation.lean` — Cross-pattern storage isolation

Conservation proofs use `List.countOcc` to account for duplicate addresses. For `NoDup` lists, transfer preserves exact sum. For general lists, exact equations with `countOcc` multipliers are proven.

## Known Limitations

- **Self-transfer**: Modeled as a no-op; transfer theorems no longer require `sender != to`.
- **Supply = sum of balances**: Requires finite address model. Proven as exact sum equations with `countOcc`, not as global invariant over all addresses.
- **`ContractResult.fst`**: Returns `default` on revert, requiring `[Inhabited a]`. Proofs using `.fst` always show result is `success` first.
- **No events, no gas**: EDSL models storage and control flow only.
- **No nested mappings**: Slot encoding helpers and smoke tests exist, but core storage semantics and proofs still lack full nested mapping support (`mapping(address => mapping(address => uint256))`).

## Compiler Development

### Generic Compilation (Completed 2026-02-10)

**Problem**: Manual IR translation for each contract (unmaintainable and repetitive).

**Solution**: Declarative contract specification DSL with automatic IR generation.

**Result**: All 7 contracts compile automatically. Zero manual IR. Generated code is more optimized than manual translations.

**Implementation** (as of 2026-02-13):
- `Compiler/ContractSpec.lean` — DSL + automatic IR compiler
  - Type-safe expression language (literals, storage, mappings, arithmetic, comparisons)
  - Statement DSL (setStorage, setMapping, require, return)
  - Automatic storage slot inference from field order
  - Constructor parameter handling (bytecode argument loading)
- `Compiler/Specs.lean` — All 7 contract specifications
- `Compiler/Selector.lean` — Function selector computation (Solidity keccak256)
- `Compiler/Main.lean` — New compilation entry point

**Before**:
```lean
// Manual IR for each contract (long, repetitive)
private def ownedContract : IRContract :=
  let deployBody := [
    stmtLet "argsOffset" (call "sub" [call "codesize" [], lit 32]),
    stmtExpr (call "codecopy" [lit 0, ident "argsOffset", lit 32]),
    stmtLet "initialOwner" (call "and" [call "mload" [lit 0], hex addressMask]),
    sstoreSlot 0 (ident "initialOwner")
  ]
  // ... more manual Yul construction
```

**After**:
```lean
// Declarative spec (compact, declarative)
def ownedSpec : ContractSpec := {
  name := "Owned"
  fields := [{ name := "owner", ty := FieldType.address }]
  constructor := some {
    params := [{ name := "initialOwner", ty := ParamType.address }]
    body := [Stmt.setStorage "owner" (Expr.constructorArg 0)]
  }
  functions := [/* ... high-level DSL */]
}
```

**Metrics**:
- Manual IR eliminated in favor of generated IR from the spec
- Time to add contract dropped significantly in practice
- Test results: Foundry tests pass (290/290 as of 2026-02-15), Lean proofs verify (296 EDSL theorems as of 2026-02-15)
- Code quality: More concise, optimized (expression inlining)

**Features Achieved**:
- ✅ Automatic storage slot inference
- ✅ Constructor parameter support
- ✅ Function selector management
- ✅ Type-safe DSL prevents errors
- ✅ Code optimization

**Usage**:
```bash
lake build verity-compiler    # Build compiler
lake exe verity-compiler      # Generate all contracts
forge test  # 290/290 tests pass (as of 2026-02-15)
```

### Differential Testing (Completed 2026-02-10)

**Problem**: No way to trust compiler correctness without formal proofs. Need high confidence that compiled EVM matches verified EDSL semantics.

**Solution**: Random transaction generation + parallel execution on EDSL interpreter and compiled EVM bytecode.

**Result**: default runs use 100 random transactions per contract, while CI scales the large suite to 10,000+ per contract. Zero mismatches detected so far.

**Implementation** (as of 2026-02-13):
- `Compiler/Interpreter.lean` — EDSL interpreter for differential testing
  - Executes EDSL contracts on abstract state
  - Returns JSON results for comparison with EVM
  - Supports SimpleStorage and Counter (extensible to all contracts)
- `Compiler/RandomGen.lean` — Random transaction generator
  - Generates random addresses, values, and function calls
  - Contract-specific transaction generation (store/retrieve for SimpleStorage)
- `test/DifferentialSimpleStorage.t.sol` — Foundry test harness
  - Executes transactions on compiled EVM bytecode
  - Calls EDSL interpreter via `vm.ffi`
  - Compares: success/revert, return values, storage changes
  - Tracks independent state for EVM and EDSL

**Critical Fixes** (Bugbot second review):
1. **EDSL State Independence**: Fixed bug where EVM results were fed back to EDSL state tracker, making tests always match. Added JSON parsing to maintain separate EDSL and EVM state.
2. **Test Assertions**: Added `assertTrue` checks to prevent silent test failures.
3. **Underflow Guards**: Added length guards to JSON parsing to prevent underflow reverts.
4. **Clang Crash**: Removed `deriving Repr` to fix CI compilation crash (Lean generated overly complex C code).
5. **Mapping Change De-duplication**: Mapping change keys are de-duplicated before comparison to avoid self-transfer double counting and reduce diff output size.

**Test Results**:
- 100/100 random transactions pass per contract in default runs
- 10,000+ random transactions pass per contract in CI (large suite)
- Large suite is sharded across 8 CI jobs to stay within per-test gas limits
- Zero mismatches detected
- All Foundry tests passing (290/290 as of 2026-02-15)
- CI: All checks passing

**Usage**:
```bash
lake build Compiler.Interpreter           # Build interpreter
lake exe difftest-interpreter simpleStorage store 0 100  # Run single tx
forge test --match-contract Differential  # Run default (100) random tests
# Scale the large suite (used in CI):
DIFFTEST_RANDOM_LARGE=10000 forge test --match-contract Differential
# Shard the large suite (CI uses 8 shards):
DIFFTEST_SHARD_COUNT=8 DIFFTEST_SHARD_INDEX=0 DIFFTEST_RANDOM_LARGE=10000 \
  forge test --match-contract Differential
```

**Remaining Work**:

**A. Scale Differential Testing**:
- Centralize the "random run" entrypoint so each harness can opt into the same seed/count knobs.
- Add adversarial patterns: boundary overflows, more edge cases.
- **Done when**: random harness setup is shared and parameterized across all 7 contracts.

**B. Property Extraction (Proofs → Tests)**:
- Reduce exclusions. Add property tests contract‑by‑contract. Keep coverage script green.

**C. Address Known Limitations (Core Modeling)**:
- Full "supply = sum balances" proof over a finite address set (PR #47 foundation, PR #51 infrastructure).
- Extend storage semantics + proofs for nested mappings to support allowances (`approve`/`transferFrom`).

**D. Reduce Remaining Trust Assumptions**:
- Prove selector hashes in Lean (not just CI fixture checks).
- Add a minimal Yul↔EVM semantic bridge lemma or mechanized model.

**E. Documentation**:
- Add the 1‑page "add a contract" guide and keep roadmap updates in sync with each milestone.

See [`docs/ROADMAP.md`](/docs/ROADMAP.md) for the full roadmap and timeline.

## Detailed Logs

For iteration-by-iteration development notes, see [/research/iterations](/research/iterations).
