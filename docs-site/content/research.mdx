---
title: Research & Development
description: Design decisions, iterations, and proof techniques
---

# Research & Development

**Compact core, built across 7 iterations. Zero sorry, zero axioms.**

## Evolution

The project evolved in two phases:

**Phase 1 (Iterations 1-7)**: Built 7 contracts on `StateM ContractState`. The core stayed intentionally small while storage types were added incrementally: `Nat -> Uint256` (iteration 1), `Nat -> Address` (iteration 3), `Nat -> Address -> Uint256` for mappings (iteration 6). Each addition was driven by a concrete example that needed it.

**Phase 2 (Verification)**: Replaced `StateM` with custom `ContractResult` type (`success | revert`) to model `require` guards explicitly. This enabled proving properties like "mint reverts when caller is not owner." The core expanded to include proof automation lemmas and EVM context fields.

## Progress and Roadmap (as of 2026-02-14)

This is the single source of truth for progress, roadmap, and milestone updates.

- **Layer 1 (Spec Correctness)**: Complete for all 7 contracts.
- **Layer 2 (ContractSpec → IR)**: Complete for all 7 contracts (per‑function preservation theorems compiled in Lean).
- **Layer 3 (IR → Yul)**: In progress (generic equivalence scaffolding + Yul/IR fuel‑unfolding lemmas + local reducibility for `execIRStmt/execIRStmts` inside equivalence proofs + fuel‑bounded IR↔Yul sequence lemma + fuel‑based function equivalence goal + fuel‑bounded function lemma from aligned IR state + explicit fuel‑adequacy goal definitions for IR + adequacy‑lifting lemma from stmt‑level goal to function‑level goal; full contract‑level equivalence theorems not yet proven).

Recent updates:
- CI now installs `solc` with `sudo` to avoid permission failures on GitHub Actions runners.
- CI now downloads generated Yul artifacts into `compiler/` so Foundry tests use fresh outputs.
- Mapping slot encoding restores the defensive `baseSlot % evmModulus` normalization.
- Documented that stmt‑level fuel adequacy remains blocked due to opaque `execIRStmts` (goal defined, proof not yet available).
- Added a helper lemma that combines stmt‑level equivalence + function‑level adequacy into a non‑fuel function equivalence result.
- Scoped `supply_equals_sum` as a private helper until it is actually used in total‑supply proofs (keeps the public invariant surface minimal).
- Nested mapping encoding now preserves tagged base slots so nested slots round‑trip without losing tags.
- Removed unused `decodeNestedMappingSlot` helper to reduce dead code.

## Iterations

| Iteration | Contract | Core Change | Key Feature |
|-----------|----------|-------------|-------------|
| 1 | SimpleStorage | Bootstrap | `ContractState`, storage ops, `require` |
| 2 | Counter | Reuse | Read-modify-write pattern |
| 3 | Owned | Extend | Address storage, access control |
| 4 | OwnedCounter | Compose | Pattern composition |
| 5 | SafeCounter | Extend | Math stdlib with checked arithmetic |
| 6 | Ledger | Extend | Mapping support (`Address -> Uint256`) |
| 7 | SimpleToken | Compose | Combined patterns: owned + ledger + supply |

## Design Decisions

**What worked:**
- `Address := String`, `Uint256` is a dedicated 256-bit modular type.
- Storage as functions (`Nat -> Uint256`), not finite maps. Uninitialized slots return 0.
- `require` returns `ContractResult.revert msg s`, preserving original state.
- Manual storage slot allocation (slot 0, 1, 2...). No automatic allocation needed.
- Selector maps remain explicit per contract (no ContractSpec-derived builder yet).
- `onlyOwner` is a regular function, not special syntax.

**What didn't work:**
- `StateM.get` doesn't exist in Lean 4. Use plain `get` in do-notation.
- `Repr` can't derive for function types. Added manual instance.
- Generic `requireSome` needs `[Inhabited a]`. Made Uint256-specific version instead.
- Marking `.fst`/`.snd` as `@[simp]` caused over-simplification. Added operation-specific simp lemmas.

## Arithmetic Semantics

All core arithmetic is EVM‑compatible. `Uint256` wraps at `2^256`, so `+`, `-`, `*`, `/`, and `%` match EVM behavior by default.

Two approaches coexist for overflow safety:
- **Counter / Ledger / SimpleToken**: Bare `+`/`-` (modular arithmetic, EVM‑accurate)
- **SafeCounter**: `safeAdd`/`safeSub` from `Stdlib/Math.lean` return `Option`, reverting on overflow/underflow

`MAX_UINT256 := 2^256 - 1`. Safe arithmetic checks this bound before returning `some`.

## Proof Techniques

**Full unfolding** is the main approach:
```lean
simp only [operation, onlyOwner, isOwner, owner,
  msgSender, getStorageAddr, setStorage,
  DumbContracts.bind, Bind.bind, Pure.pure,
  Contract.run, ContractResult.snd]
simp [h_owner]
```

Works because the EDSL is shallow: every contract function is a composition of core primitives.

**Private unfold helpers** pre-compute exact result states when guards pass:
```lean
private theorem increment_unfold (s : ContractState)
  (h_owner : s.sender = s.storageAddr 0) :
  (increment.run s) = ContractResult.success () { ... } := by
  simp only [increment, ...]; simp [h_owner]
```

But `private theorem` isn't accessible from other files. Isolation proofs in separate files must repeat the full unfolding.

**Other techniques:**
- **Boolean equality**: Use `beq_iff_eq` to convert `(x == y) = true` to `x = y`
- **Slot preservation**: `intro slot h_neq h_eq; exact absurd h_eq h_neq`
- **List sum reasoning**: `omega` can't handle `List.sum` or `var * var`. Use explicit `Nat.add_assoc`/`add_comm`/`add_left_comm` chains
- **No Mathlib**: `push_neg`, `set`, `ring`, `linarith` unavailable. Use `by_cases`, explicit witnesses, manual `Nat.*` lemma chains

## Verification Structure

Each contract has:
- `DumbContracts/Examples/X.lean` — Implementation
- `DumbContracts/Specs/X/Spec.lean` — Pre/postconditions for each operation
- `DumbContracts/Specs/X/Invariants.lean` — State properties that should hold
- `DumbContracts/Specs/X/Proofs.lean` — Layer 1: Spec correctness vs EDSL
- `DumbContracts/Proofs/X/Basic.lean` — Spec conformance, basic properties
- `DumbContracts/Proofs/X/Correctness.lean` — Revert proofs, composition, end-to-end

Some contracts have additional proof files:
- `DumbContracts/Proofs/SimpleToken/Supply.lean` — Supply conservation equations
- `DumbContracts/Proofs/SimpleToken/Isolation.lean` — Storage isolation across slot types
- `DumbContracts/Proofs/Ledger/Conservation.lean` — Balance conservation equations
- `DumbContracts/Proofs/OwnedCounter/Isolation.lean` — Cross-pattern storage isolation

Conservation proofs use `List.countOcc` to account for duplicate addresses. For `NoDup` lists, transfer preserves exact sum. For general lists, exact equations with `countOcc` multipliers are proven.

## Known Limitations

- **Self-transfer**: Modeled as a no-op; transfer theorems no longer require `sender != to`.
- **Supply = sum of balances**: Requires finite address model. Proven as exact sum equations with `countOcc`, not as global invariant over all addresses.
- **`ContractResult.fst`**: Returns `default` on revert, requiring `[Inhabited a]`. Proofs using `.fst` always show result is `success` first.
- **No events, no gas**: EDSL models storage and control flow only.
- **No nested mappings**: Slot encoding helpers and smoke tests exist, but core storage semantics and proofs still lack full nested mapping support (`mapping(address => mapping(address => uint256))`).

## Compiler Development

### Generic Compilation (Completed 2026-02-10)

**Problem**: Manual IR translation for each contract (unmaintainable and repetitive).

**Solution**: Declarative contract specification DSL with automatic IR generation.

**Result**: All 7 contracts compile automatically. Zero manual IR. Generated code is more optimized than manual translations.

**Implementation** (as of 2026-02-13):
- `Compiler/ContractSpec.lean` — DSL + automatic IR compiler
  - Type-safe expression language (literals, storage, mappings, arithmetic, comparisons)
  - Statement DSL (setStorage, setMapping, require, return)
  - Automatic storage slot inference from field order
  - Constructor parameter handling (bytecode argument loading)
- `Compiler/Specs.lean` — All 7 contract specifications
- `Compiler/Selector.lean` — Function selector computation (Solidity keccak256)
- `Compiler/Main.lean` — New compilation entry point

**Before**:
```lean
// Manual IR for each contract (long, repetitive)
private def ownedContract : IRContract :=
  let deployBody := [
    stmtLet "argsOffset" (call "sub" [call "codesize" [], lit 32]),
    stmtExpr (call "codecopy" [lit 0, ident "argsOffset", lit 32]),
    stmtLet "initialOwner" (call "and" [call "mload" [lit 0], hex addressMask]),
    sstoreSlot 0 (ident "initialOwner")
  ]
  // ... more manual Yul construction
```

**After**:
```lean
// Declarative spec (compact, declarative)
def ownedSpec : ContractSpec := {
  name := "Owned"
  fields := [{ name := "owner", ty := FieldType.address }]
  constructor := some {
    params := [{ name := "initialOwner", ty := ParamType.address }]
    body := [Stmt.setStorage "owner" (Expr.constructorArg 0)]
  }
  functions := [/* ... high-level DSL */]
}
```

**Metrics**:
- Manual IR eliminated in favor of generated IR from the spec
- Time to add contract dropped significantly in practice
- Test results: Foundry tests pass (264/264 as of 2026-02-13), Lean proofs verify (252/252 as of 2026-02-13)
- Code quality: More concise, optimized (expression inlining)

**Features Achieved**:
- ✅ Automatic storage slot inference
- ✅ Constructor parameter support
- ✅ Function selector management
- ✅ Type-safe DSL prevents errors
- ✅ Code optimization

**Usage**:
```bash
lake build dumbcontracts-compiler    # Build compiler
lake exe dumbcontracts-compiler      # Generate all contracts
forge test  # 264/264 tests pass (as of 2026-02-13)
```

### Differential Testing (Completed 2026-02-10)

**Problem**: No way to trust compiler correctness without formal proofs. Need high confidence that compiled EVM matches verified EDSL semantics.

**Solution**: Random transaction generation + parallel execution on EDSL interpreter and compiled EVM bytecode.

**Result**: default runs use 100 random transactions per contract, while CI scales the large suite to 10,000+ per contract. Zero mismatches detected so far.

**Implementation** (as of 2026-02-13):
- `Compiler/Interpreter.lean` — EDSL interpreter for differential testing
  - Executes EDSL contracts on abstract state
  - Returns JSON results for comparison with EVM
  - Supports SimpleStorage and Counter (extensible to all contracts)
- `Compiler/RandomGen.lean` — Random transaction generator
  - Generates random addresses, values, and function calls
  - Contract-specific transaction generation (store/retrieve for SimpleStorage)
- `test/DifferentialSimpleStorage.t.sol` — Foundry test harness
  - Executes transactions on compiled EVM bytecode
  - Calls EDSL interpreter via `vm.ffi`
  - Compares: success/revert, return values, storage changes
  - Tracks independent state for EVM and EDSL

**Critical Fixes** (Bugbot second review):
1. **EDSL State Independence**: Fixed bug where EVM results were fed back to EDSL state tracker, making tests always match. Added JSON parsing to maintain separate EDSL and EVM state.
2. **Test Assertions**: Added `assertTrue` checks to prevent silent test failures.
3. **Underflow Guards**: Added length guards to JSON parsing to prevent underflow reverts.
4. **Clang Crash**: Removed `deriving Repr` to fix CI compilation crash (Lean generated overly complex C code).
5. **Mapping Change De-duplication**: Mapping change keys are de-duplicated before comparison to avoid self-transfer double counting and reduce diff output size.

**Test Results**:
- 100/100 random transactions pass per contract in default runs
- 10,000+ random transactions pass per contract in CI (large suite)
- Large suite is sharded across 8 CI jobs to stay within per-test gas limits
- Zero mismatches detected
- All Foundry tests passing (264/264 as of 2026-02-13)
- CI: All checks passing

**Usage**:
```bash
lake build Compiler.Interpreter           # Build interpreter
lake exe difftest-interpreter simpleStorage store 0 100  # Run single tx
forge test --match-contract Differential  # Run default (100) random tests
# Scale the large suite (used in CI):
DIFFTEST_RANDOM_LARGE=10000 forge test --match-contract Differential
# Shard the large suite (CI uses 8 shards):
DIFFTEST_SHARD_COUNT=8 DIFFTEST_SHARD_INDEX=0 DIFFTEST_RANDOM_LARGE=10000 \
  forge test --match-contract Differential
```

**Structured Next Steps (A–G)**:

**A. Finish Layer 2 (ContractSpec → IR)**:
- ✅ SimpleStorage + Counter preservation proofs are pinned and compiling.
- ✅ Generalized preservation proofs now cover Owned, OwnedCounter, SafeCounter, Ledger, and SimpleToken.
- ✅ Conversion relations for mappings + address types are exercised in the full suite of Layer 2 proofs.
- ✅ Removed the exploratory `StoreProofAttempt.lean` once the real proof path was in place.
- **Done when**: each contract has a Layer 2 preservation theorem that compiles in Lean (met).

**B. Finish Layer 3 (IR → Yul)**:
- **Layer 3 proof equivalence (IR → Yul) — generic path**
  - Instruction‑level IR↔Yul equivalence lemmas.
  - ✅ Fuel‑unfolding lemmas for Yul statement lists (`execYulStmtsFuel_nil/cons`) added in `Compiler/Proofs/YulGeneration/Equivalence.lean`.
  - ✅ Fuel‑unfolding lemmas for IR statement lists (`execIRStmtsFuel_nil/cons`) added in `Compiler/Proofs/YulGeneration/Equivalence.lean`.
  - ✅ `execIRStmts` marked reducible for proof unfolding in `Compiler/Proofs/YulGeneration/Equivalence.lean`.
  - ✅ Fuel‑adequacy goals defined (`execIRStmtsFuel_adequate_goal`, `execIRFunctionFuel_adequate_goal`).
  - Sequence/program equivalence lemma (composition + state mapping) still needs a clean non‑fuel bridge on the IR side (fuel adequacy). Current blocker: `execIRStmts` unfolding/adequacy proof still open.
  - Generic function equivalence theorem (parameterized by function + compiler) still needs a non‑fuel bridge.
  - Contract‑level equivalence is then purely mechanical instantiation (no new proof ideas).
  - **Done when**: instruction‑level lemmas exist, the generic function theorem compiles, and contracts are instantiated mechanically without new proof ideas.

**C. Scale Differential Testing**:
- Centralize the “random run” entrypoint so each harness can opt into the same seed/count knobs (avoid copy‑paste and drift).
- Increase transaction counts from 100 to 10,000+ per contract (keep a quick-run default, allow override for CI).
- Add adversarial patterns: self-transfer (done), max uint values (done for SimpleStorage/Ledger/SimpleToken), boundary overflows.
- **Done when**: CI runs a 10,000+ tx suite per contract, and the random harness setup is shared and parameterized across all 7 contracts.

**D. Property Extraction (Proofs → Tests)**:
- **Remaining**: Reduce 172 exclusions. Add property tests contract‑by‑contract and decide if any Stdlib proofs are “proof‑only.” Keep coverage script green.

**E. Address Known Limitations (Core Modeling)**:
- ✅ SimpleToken transfer preservation lemmas no longer require `sender ≠ to`, aligning proofs with self-transfer no-op behavior.
- **Remaining**: Full “supply = sum balances” proof over a finite address set plus tests. Extend storage semantics + proofs for nested mappings to support allowances (`approve`/`transferFrom`). Add explicit self‑transfer property tests across affected contracts.

**F. Reduce Remaining Trust Assumptions**:
- **Remaining**: Prove selector hashes in Lean (not just CI fixture checks). Add a minimal Yul↔EVM semantic bridge lemma or mechanized model.

**G. Documentation (Optional But Valuable)**:
- **Remaining**: Add the 1‑page “add a contract” guide and keep roadmap updates in sync with each milestone.

**Trust Model**: 100 random tests provide probabilistic confidence. Formal verification (Item 4) would provide mathematical certainty.

### Future: Property Extraction & Compiler Verification

**Property Extraction** (Roadmap Item 3):
- Parse 252 proven theorems from EDSL files
- Generate Foundry property tests from theorem statements
- Example: `transfer_total_supply` theorem → Foundry invariant test
- Result: 252 theorems verified in both proofs and on-chain tests

**Compiler Verification** (Roadmap Item 4, long-term):
- Formalize EVM execution in Lean
- Prove: `∀ contract state tx, evm_exec (compile contract) state tx = edsl_exec contract state tx`
- Eliminates all trust assumptions in the compilation pipeline

## What Could Come Next

See **Structured Next Steps (A–G)** above for the single source of truth. The older “next steps” list has been removed to avoid drift and duplication.

## Detailed Logs

For iteration-by-iteration development notes, see [/research/iterations](/research/iterations).
