---
title: Formal Verification
description: EDSL proofs plus compiler correctness proofs (IR + Yul)
---

# Formal Verification

The compiler is verified with IR preservation proofs and Yul equivalence proofs in `Compiler/Proofs/`. All three layers are complete and checked by `lake build`.

**Status**: 305 theorems across 9 categories. 299 fully proven, 6 `sorry` placeholders in Ledger sum property proofs ([#65](https://github.com/Th0rgal/verity/issues/65)). 2 axioms documented in [AXIOMS.md](https://github.com/Th0rgal/verity/blob/main/AXIOMS.md).

## Snapshot (2026-02-16)

- EDSL theorems: 305 across 9 categories (7 contracts + ReentrancyExample + Stdlib).
- SimpleStorage: 20 total (Basic 12, Correctness 7, Spec 1).
- Counter: 28 total (Basic 19, Correctness 10).
- Owned: 22 total (Basic 18, Correctness 4).
- SimpleToken: 59 total (Basic 34, Correctness 12, Supply 6, Isolation 9).
- OwnedCounter: 45 total (Basic 29, Correctness 6, Isolation 14).
- Ledger: 33 total (Basic 21, Correctness 6, Conservation 13 — 12 sorry).
- SafeCounter: 25 total (Basic 22, Correctness 9).
- ReentrancyExample: 4 total (inline proofs: vulnerability existence, supply invariant).
- Stdlib: 64 theorems (Math 25, Automation 39).

## Compiler Proofs (IR + Yul)

- **Spec semantics**: `Verity/Proofs/Stdlib/SpecInterpreter.lean`
- **IR generation**: `Compiler/Proofs/IRGeneration/` (complete for all 7 contracts)
- **Yul semantics + preservation**: `Compiler/Proofs/YulGeneration/` (complete — PR #42)

## Structure

Each contract has three layers of files:

```
Verity/
├── Examples/{Contract}.lean      # Implementation
├── Specs/{Contract}/
│   ├── Spec.lean                 # What each operation should do
│   └── Invariants.lean           # Properties that should always hold
│   └── Proofs.lean               # User-facing proofs (spec → impl)
├── Proofs/Stdlib/                # Reusable proof infrastructure
└── Proofs/{Contract}/            # Deeper contract proof suites
    ├── Basic.lean                # Core properties and lemmas
    ├── Correctness.lean          # Composition and revert behavior
    ├── Conservation.lean         # Sum conservation laws (Ledger)
    ├── Supply.lean               # Supply conservation (SimpleToken)
    └── Isolation.lean            # Storage isolation (SimpleToken)
```

## Guard modeling

The `ContractResult` type models Solidity's `require` explicitly:

```lean
inductive ContractResult (α : Type) where
  | success : α → ContractState → ContractResult α
  | revert : String → ContractState → ContractResult α

def require (condition : Bool) (message : String) : Contract Unit :=
  fun s => if condition
           then ContractResult.success () s
           else ContractResult.revert message s
```

This lets proofs reason about both the success path and the revert path of guard-protected operations.

## Theorems by contract

### SimpleStorage

**Basic:**

| # | Theorem | Property |
|---|---------|----------|
| 1 | `store_retrieve_correct` | After storing v, retrieve returns v |
| 2 | `store_meets_spec` | Store satisfies formal specification |
| 3 | `retrieve_meets_spec` | Retrieve satisfies formal specification |
| 4 | `setStorage_updates_slot` | Updates the correct storage slot |
| 5 | `setStorage_preserves_other_slots` | Other slots unchanged |
| 6 | `setStorage_preserves_addr_storage` | Address storage unaffected |
| 7 | `setStorage_preserves_map_storage` | Mapping storage unaffected |
| 8 | `setStorage_preserves_sender` | msg.sender preserved |
| 9 | `setStorage_preserves_address` | Contract address preserved |
| 10 | `store_preserves_wellformedness` | Well-formed state maintained |
| 11 | `retrieve_preserves_state` | Read doesn't modify state |
| 12 | `store_retrieve_spec_composition` | Spec composition correctness |

**Correctness:**

| # | Theorem | Property |
|---|---------|----------|
| 1 | `store_retrieve_roundtrip_holds` | Roundtrip specification |
| 2 | `store_preserves_storage_isolated` | Storage isolation |
| 3 | `store_preserves_addr_storage` | Address storage preservation |
| 4 | `store_preserves_map_storage` | Mapping storage preservation |
| 5 | `store_preserves_context` | Context (sender, thisAddress) preservation |
| 6 | `retrieve_preserves_context` | Read-only preserves context |
| 7 | `retrieve_preserves_wellformedness` | Well-formedness preservation |

### Counter

**Basic:**

| # | Theorem | Property |
|---|---------|----------|
| 1 | `constructor_meets_spec` | Constructor sets count to 0 |
| 2 | `constructor_sets_count_zero` | Initial count is zero |
| 3 | `getValue_meets_spec` | getValue reads correct slot |
| 4 | `getValue_returns_count` | Returns stored count |
| 5 | `increment_meets_spec` | Increment satisfies spec |
| 6 | `increment_adds_one` | Count increases by exactly 1 |
| 7 | `increment_preserves_other_slots` | Other slots unchanged |
| 8 | `decrement_meets_spec` | Decrement satisfies spec |
| 9 | `decrement_subtracts_one` | Count decreases by exactly 1 |
| 10 | `increment_decrement_inverse` | Increment then decrement equals identity |
| 11 | `decrement_increment_inverse` | Decrement then increment equals identity |
| 12 | `increment_twice_adds_two` | Two increments add 2 |
| 13 | `increment_preserves_sender` | Sender preserved |
| 14 | `increment_preserves_address` | Contract address preserved |
| 15 | `increment_preserves_wellformedness` | Well-formedness maintained |
| 16 | `constructor_increment_gives_one` | Constructor then increment equals 1 |
| 17 | `constructor_getValue_gives_zero` | Constructor then getValue equals 0 |
| 18 | `decrement_preserves_other_slots` | Other slots unchanged |
| 19 | `decrement_preserves_wellformedness` | Well-formedness maintained |

**Correctness:**

| # | Theorem | Property |
|---|---------|----------|
| 1 | `increment_state_preserved_except_count` | Only count slot changes |
| 2 | `decrement_state_preserved_except_count` | Only count slot changes |
| 3 | `getCount_state_preserved` | Read-only preserves state |
| 4 | `increment_getCount_meets_spec` | Increment then getCount |
| 5 | `decrement_getCount_meets_spec` | Decrement then getCount |
| 6 | `two_increments_meets_spec` | Two increments composition |
| 7 | `increment_decrement_meets_cancel` | Cancellation property |
| 8 | `getCount_preserves_wellformedness` | Read-only well-formedness |
| 9 | `decrement_getCount_correct` | Decrement then getCount equals count - 1 |
| 10 | `decrement_at_zero_stays_zero` | Decrementing at zero saturates to zero |

### Owned

**Basic:**

| # | Theorem | Property |
|---|---------|----------|
| 1 | `constructor_meets_spec` | Constructor sets owner to sender |
| 2 | `constructor_sets_owner` | Owner equals deployer |
| 3 | `getOwner_meets_spec` | getOwner reads correct slot |
| 4 | `getOwner_returns_owner` | Returns stored owner |
| 5 | `isOwner_correct_when_owner` | isOwner returns true for owner |
| 6 | `isOwner_correct_when_not_owner` | isOwner returns false for non-owner |
| 7 | `constructor_getOwner_composition` | Constructor then getOwner equals sender |
| 8-12 | Storage preservation theorems | Slots, sender, address preserved |
| 13 | `constructor_preserves_wellformedness` | Well-formedness maintained |
| 14 | `transferOwnership_preserves_other_slots` | Other slots unchanged |
| 15 | `transferOwnership_preserves_wellformedness` | Well-formedness maintained |
| 16 | `transferOwnership_reverts_when_not_owner` | Non-owner calls revert |
| 17 | `transferOwnership_meets_spec_when_owner` | Owner transfer satisfies spec |
| 18 | `transferOwnership_changes_owner_when_allowed` | Owner successfully changed |

**Correctness:**

| # | Theorem | Property |
|---|---------|----------|
| 1 | `transferOwnership_reverts_when_not_owner` | Access control enforced |
| 2 | `transferOwnership_preserves_wellformedness` | Well-formedness with non-empty owner |
| 3 | `constructor_transferOwnership_getOwner` | Full lifecycle: create, transfer, read |
| 4 | `transferred_owner_cannot_act` | Old owner is actually locked out |

### SimpleToken

**Basic:**

| # | Theorem | Property |
|---|---------|----------|
| 1-4 | Constructor theorems | Sets owner, zero supply, zero balances |
| 5-8 | Read operation theorems | balanceOf, getTotalSupply, getOwner correct |
| 9-12 | Composition theorems | Constructor then read operations |
| 13-16 | Storage preservation | Constructor preserves other state |
| 17 | Well-formedness | Constructor maintains well-formedness |
| 18 | `mint_meets_spec_when_owner` | Owner mint satisfies full spec |
| 19 | `mint_increases_balance` | Recipient balance increases by amount |
| 20 | `mint_increases_supply` | Total supply increases by amount |
| 21 | `mint_reverts_when_not_owner` | Non-owner mint reverts |
| 22-25 | Mint preservation | Mint preserves sender, address, other state |
| 26 | `transfer_meets_spec_when_sufficient` | Transfer satisfies spec (sender != to) |
| 27 | `transfer_preserves_supply_when_sufficient` | Transfer doesn't change supply |
| 28 | `transfer_decreases_sender_balance` | Sender balance decreases |
| 29 | `transfer_increases_recipient_balance` | Recipient balance increases |
| 30-36 | Transfer preservation | Transfer preserves sender, address, other state |

**Correctness:**

| # | Theorem | Property |
|---|---------|----------|
| 1 | `mint_reverts_when_not_owner` | Non-owners cannot mint |
| 2 | `transfer_reverts_insufficient_balance` | No overdrafts |
| 3 | `mint_preserves_wellformedness` | WellFormedState survives mint |
| 4 | `transfer_preserves_wellformedness` | WellFormedState survives transfer |
| 5 | `mint_preserves_owner` | Mint doesn't change owner |
| 6 | `transfer_preserves_owner` | Transfer doesn't change owner |
| 7 | `mint_then_balanceOf_correct` | After mint, balanceOf returns updated balance |
| 8 | `mint_then_getTotalSupply_correct` | After mint, getTotalSupply returns updated supply |
| 9 | `transfer_then_balanceOf_sender_correct` | After transfer, sender balance decreased |
| 10 | `transfer_then_balanceOf_recipient_correct` | After transfer, recipient balance increased |

**Supply Conservation:**

| # | Theorem | Property |
|---|---------|----------|
| 1 | `constructor_establishes_supply_bounds` | Constructor establishes supply invariant |
| 2 | `mint_sum_equation` | `new_sum = old_sum + count(to) * amount` |
| 3 | `transfer_sum_equation` | `new_sum + count(sender)*amt = old_sum + count(to)*amt` |
| 4 | `transfer_sum_bounded` | `new_sum <= old_sum + count(to) * amount` |
| 5-9 | Helper lemmas | countOcc, map_sum_point_update, map_sum_transfer_eq |

Transfer proofs now handle self-transfer by modeling it as a no-op (preloading balances and applying a zero delta), so `sender != to` is no longer required. Supply conservation still uses exact sum equations rather than the `supply_bounds_balances` invariant, which cannot be preserved for lists with duplicate addresses.

**Isolation:**

| # | Theorem | Property |
|---|---------|----------|
| 1 | `constructor_supply_storage_isolated` | Constructor only writes Uint256 slot 2 |
| 2 | `constructor_balance_mapping_isolated` | Constructor doesn't write any mapping slot |
| 3 | `constructor_owner_addr_isolated` | Constructor only writes Address slot 0 |
| 4 | `mint_supply_storage_isolated` | Mint only writes Uint256 slot 2 |
| 5 | `mint_balance_mapping_isolated` | Mint only writes Mapping slot 1 |
| 6 | `mint_owner_addr_isolated` | Mint doesn't write any Address slot |
| 7 | `transfer_supply_storage_isolated` | Transfer doesn't write any Uint256 slot |
| 8 | `transfer_balance_mapping_isolated` | Transfer only writes Mapping slot 1 |
| 9 | `transfer_owner_addr_isolated` | Transfer doesn't write any Address slot |

### OwnedCounter

**Basic:**

| # | Theorem | Property |
|---|---------|----------|
| 1-3 | Constructor | Sets owner, preserves count |
| 4-10 | Read operations | getCount, getOwner, isOwner correctness |
| 11-14 | Increment (owner-guarded) | Spec, adds one, reverts for non-owner |
| 15-18 | Decrement (owner-guarded) | Spec, subtracts one, reverts for non-owner |
| 19-22 | TransferOwnership (owner-guarded) | Spec, changes owner, reverts for non-owner |
| 23-25 | Isolation | increment/decrement preserve owner, transfer preserves count |
| 26-29 | Composition/preservation | constructor then increment, well-formedness |

**Correctness:**

| # | Theorem | Property |
|---|---------|----------|
| 1 | `transfer_then_increment_reverts` | Old owner locked out of increment |
| 2 | `transfer_then_decrement_reverts` | Old owner locked out of decrement |
| 3 | `transfer_then_transfer_reverts` | Old owner locked out of re-transfer |
| 4 | `transferOwnership_preserves_wellformedness` | Well-formedness preservation |
| 5 | `increment_survives_transfer` | Counter value survives ownership transfer |

### Ledger

**Basic:**

| # | Theorem | Property |
|---|---------|----------|
| 1-3 | getBalance | Spec, returns balance, read-only |
| 4-7 | Deposit | Spec, increases balance, preserves others |
| 8-11 | Withdraw | Spec, decreases balance, reverts insufficient |
| 12-16 | Transfer | Spec, decreases sender, increases recipient, reverts insufficient |
| 17-21 | Preservation | Non-mapping storage, well-formedness, deposit-getBalance composition |

**Correctness:**

| # | Theorem | Property |
|---|---------|----------|
| 1 | `transfer_preserves_wellformedness` | Transfer preserves WellFormedState |
| 2 | `transfer_preserves_non_mapping` | Transfer preserves non-mapping storage |
| 3 | `withdraw_getBalance_correct` | After withdraw, getBalance returns decreased balance |
| 4 | `transfer_getBalance_sender_correct` | After transfer, sender balance decreased |
| 5 | `transfer_getBalance_recipient_correct` | After transfer, recipient balance increased |
| 6 | `deposit_withdraw_cancel` | Deposit then withdraw cancellation |

**Conservation:**

| # | Theorem | Property |
|---|---------|----------|
| 1 | `deposit_sum_equation` | `new_sum = old_sum + count(sender) * amount` |
| 2 | `deposit_sum_singleton_sender` | For unique sender: `new_sum = old_sum + amount` |
| 3 | `withdraw_sum_equation` | `new_sum + count(sender) * amount = old_sum` |
| 4 | `withdraw_sum_singleton_sender` | For unique sender: `new_sum + amount = old_sum` |
| 5 | `transfer_sum_equation` | `new_sum + count(sender)*amt = old_sum + count(to)*amt` |
| 6 | `transfer_sum_preserved_unique` | For unique sender & to: `new_sum = old_sum` |
| 7 | `transfer_sum_bounded` | `new_sum <= old_sum + count(to) * amount` |
| 8 | `deposit_withdraw_sum_cancel` | Deposit then withdraw preserves total sum |
| 9-13 | Helper lemmas | countOcc, map_sum_point_update/decrease, map_sum_transfer_eq |

### SafeCounter

**Basic:**

| # | Theorem | Property |
|---|---------|----------|
| 1-3 | getCount | Spec, returns count, read-only |
| 4-7 | Increment | Spec, adds one, preserves slots, reverts overflow |
| 8-11 | Decrement | Spec, subtracts one, preserves slots, reverts underflow |
| 12-13 | Well-formedness | Increment/decrement preserve well-formedness |
| 14-15 | Bounds | Increment/decrement preserve count bounds |
| 16-22 | Composition/preservation | increment then getCount, various preservation |

**Correctness:**

| # | Theorem | Property |
|---|---------|----------|
| 1-2 | Context preservation | increment/decrement preserve context |
| 3-4 | Storage isolation | increment/decrement preserve storage isolation |
| 5-6 | Read-only | getCount preserves context, well-formedness |
| 7 | `increment_decrement_cancel` | Increment then decrement cancellation |
| 8 | `decrement_getCount_correct` | Decrement then getCount equals count - 1 |

### Stdlib/Math

| # | Theorem | Property |
|---|---------|----------|
| 1 | `safeMul_some` | Returns product when no overflow |
| 2 | `safeMul_none` | Returns none on overflow |
| 3 | `safeMul_zero_left` | 0 * b equals 0, always safe |
| 4 | `safeMul_zero_right` | a * 0 equals 0, always safe |
| 5 | `safeMul_one_left` | 1 * b equals b when bounded |
| 6 | `safeMul_one_right` | a * 1 equals a when bounded |
| 7 | `safeMul_comm` | Commutativity |
| 8 | `safeMul_result_bounded` | Successful result less than or equal to MAX_UINT256 |
| 9 | `safeDiv_some` | Returns quotient when divisor nonzero |
| 10 | `safeDiv_none` | Returns none on division by zero |
| 11 | `safeDiv_zero_numerator` | 0 / b equals 0 |
| 12 | `safeDiv_by_one` | a / 1 equals a |
| 13 | `safeDiv_self` | a / a equals 1 (when a > 0) |
| 14 | `safeDiv_result_le_numerator` | Result never exceeds numerator |

## Proof techniques

**Full unfolding**: For guarded operations, unfold the entire do-notation chain through bind/pure/Contract.run/ContractResult.snd, then `simp [h_guard]` to resolve the guard condition.

**Private unfold helpers**: For complex operations, a private theorem pre-computes the exact result state when guards pass. Main proofs then `rw [op_unfold]` to get the concrete state.

**Boolean equality conversion**: `beq_iff_eq` converts between `(x == y) = true` and `x = y`.

**List sum reasoning**: `omega` cannot handle `List.sum` or nonlinear multiplication, so conservation proofs use explicit `Nat.add_assoc`/`Nat.add_comm`/`Nat.add_left_comm` rewrite chains.

**countOcc helpers**: `simp [countOcc, if_pos rfl]` produces `if True then 1 else 0` which doesn't reduce. Pre-proven `countOcc_cons_eq`/`countOcc_cons_ne` helpers avoid this.

## Known limitations

1. Uint256 is a dedicated 256-bit modular type; `+`, `-`, `*`, `/`, and `%` wrap at `2^256`
2. No multi-contract interaction
3. No reentrancy modeling
4. `supply_bounds_balances` not preserved for lists with duplicates; exact sum equations are proven instead
5. No Mathlib: `set`, `ring`, `linarith` unavailable
