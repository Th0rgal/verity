---
title: Core Architecture
description: Understanding the 212-line core with ContractResult monad
---

# Core Architecture

The Dumb Contracts core is **212 lines** of Lean 4 code that provides all primitives needed for smart contract development, including explicit success/failure modeling via the `ContractResult` type.

## Design Philosophy

1. **Minimal** — Only essential primitives
2. **Type-safe** — Catch errors at compile-time
3. **Composable** — Patterns combine naturally
4. **Verifiable** — Explicit semantics enable formal proofs
5. **Extensible** — Stdlib adds functionality without core changes

## Core Components

### 1. Basic Types

```lean
abbrev Address := String
abbrev Uint256 := Nat
abbrev Bool' := Bool
abbrev Bytes := List Nat
```

Simple type aliases for Ethereum primitives.

### 2. StorageSlot

```lean
structure StorageSlot (α : Type) where
  slot : Nat
  deriving Repr
```

Type-safe storage abstraction that prevents mixing types at compile-time.

### 3. ContractState

```lean
structure ContractState where
  storage : Nat → Uint256                -- Uint256 storage
  storageAddr : Nat → Address            -- Address storage
  storageMap : Nat → Address → Uint256  -- Mapping storage
  sender : Address
  thisAddress : Address
```

State structure holding all contract storage and context.

### 4. ContractResult — The Key Innovation

```lean
inductive ContractResult (α : Type) where
  | success : α → ContractState → ContractResult α
  | revert : String → ContractState → ContractResult α
  deriving Repr
```

Explicit success/failure representation. Every contract operation returns either `success` with a value and updated state, or `revert` with an error message and unchanged state.

### 5. Contract Monad

```lean
abbrev Contract (α : Type) := ContractState → ContractResult α
```

The contract type is a function from state to result. Custom `bind` short-circuits on `revert`:

```lean
def bind (ma : Contract α) (f : α → Contract β) : Contract β :=
  fun s => match ma s with
  | ContractResult.success a s' => f a s'
  | ContractResult.revert msg s' => ContractResult.revert msg s'
```

This gives us do-notation with automatic failure propagation — just like Solidity's `require` reverts.

### 6. Storage Operations

**Uint256 Storage:**
```lean
def getStorage (s : StorageSlot Uint256) : Contract Uint256 :=
  fun state => ContractResult.success (state.storage s.slot) state

def setStorage (s : StorageSlot Uint256) (value : Uint256) : Contract Unit :=
  fun state => ContractResult.success ()
    { state with storage := fun slot =>
        if slot == s.slot then value else state.storage slot }
```

**Address Storage** and **Mapping Storage** follow the same pattern with their respective state fields.

### 7. Require Guard

```lean
def require (condition : Bool) (message : String) : Contract Unit :=
  fun s => if condition
           then ContractResult.success () s
           else ContractResult.revert message s
```

The `require` guard returns `success` when the condition holds, `revert` with the error message when it doesn't. This enables formal reasoning about guard-protected operations.

**Simp lemmas** for proof automation:
```lean
@[simp] theorem require_true (msg : String) (s : ContractState) :
  (require true msg).run s = ContractResult.success () s := by rfl

@[simp] theorem require_false (msg : String) (s : ContractState) :
  (require false msg).run s = ContractResult.revert msg s := by rfl
```

## Proof Infrastructure

The core includes `@[simp]` lemmas for every storage operation, enabling automated proof of simple properties:

```lean
@[simp] theorem getStorage_run_fst (slot : StorageSlot Uint256) (s : ContractState) :
  (getStorage slot).run s |>.fst = s.storage slot.slot := by rfl

@[simp] theorem setStorage_run_snd (slot : StorageSlot Uint256) (value : Uint256)
  (s : ContractState) :
  ((setStorage slot value).run s).snd.storage slot.slot = value := by ...
```

These lemmas power the 82 proven theorems across 4 contracts.

## Core Growth History

| Iteration | Lines | Change | Reason |
|-----------|-------|--------|--------|
| 1 (Bootstrap) | 58 | +58 | Initial core |
| 2 (Counter) | 58 | 0 | No change needed |
| 3 (Owned) | 72 | +14 | Address storage |
| 4 (OwnedCounter) | 72 | 0 | Composition works |
| 5 (SafeCounter) | 69 | -3 | Cleanup |
| 6 (Ledger) | 82 | +13 | Mapping storage |
| 7 (SimpleToken) | 82 | 0 | Composition works |
| 8 (Guard Modeling) | 212 | +130 | ContractResult, bind, simp lemmas |

**Key Insight**: The jump from 82 to 212 lines was for verification infrastructure (ContractResult type, custom bind, simp lemmas). The contract primitives themselves remain minimal.

## Type Safety

The `StorageSlot α` type parameter ensures type safety:

```lean
def owner : StorageSlot Address := ⟨0⟩
def count : StorageSlot Uint256 := ⟨1⟩
def balances : StorageSlot (Address → Uint256) := ⟨2⟩

-- This compiles:
let value ← getStorage count              -- Uint256
let addr ← getStorageAddr owner           -- Address
let bal ← getMapping balances "0xAlice"   -- Uint256

-- This won't compile:
let wrong ← getStorage owner  -- Type error! owner is Address, not Uint256
```

Type errors are caught at compile-time, preventing entire classes of bugs.

## Storage Model

Three independent storage types:

1. **Uint256 Storage** — `Nat → Uint256` (slot → value)
2. **Address Storage** — `Nat → Address` (slot → address)
3. **Mapping Storage** — `Nat → Address → Uint256` (slot → key → value)

All three coexist independently with no interference — proven by isolation theorems.

## Why ContractResult Over StateM

The original core used `StateM ContractState α`. This was simple but couldn't model `require` failures — proofs had to assume guards passed (using axioms).

`ContractResult` makes success/failure explicit:
- **Proofs can reason about both paths** (success and revert)
- **No axioms needed** — guard behavior is derived from the definition
- **Short-circuiting bind** — failures propagate automatically through do-notation
- **82/82 theorems proven** without any sorry or axioms

## Core Source

View the complete core at: [`DumbContracts/Core.lean`](https://github.com/Th0rgal/dumbcontracts/blob/main/DumbContracts/Core.lean)
