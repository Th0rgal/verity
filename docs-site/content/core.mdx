---
title: Core Architecture
description: How the 257-line core works
---

# Core Architecture

The core is intentionally small. It provides types for contract state, storage operations, a `require` guard, and `@[simp]` lemmas for proof automation.

## Types

```lean
abbrev Address := String
abbrev Uint256 := Verity.Core.Uint256

structure StorageSlot (α : Type) where
  slot : Nat
```

`StorageSlot` is parameterized by type, so `StorageSlot Uint256`, `StorageSlot Address`, and `StorageSlot (Address -> Uint256)` are all distinct. This prevents mixing storage types at compile time.

`Uint256` is a dedicated 256-bit modular integer type, so `+`, `-`, `*`, `/`, and `%` wrap exactly like the EVM.

## ContractState

```lean
structure ContractState where
  storage : Nat → Uint256                -- Uint256 storage
  storageAddr : Nat → Address            -- Address storage
  storageMap : Nat → Address → Uint256  -- Mapping storage
  sender : Address
  thisAddress : Address
  msgValue : Uint256
  blockTimestamp : Uint256
```

Three independent storage spaces: Uint256 slots, Address slots, and Mapping slots. Each is indexed by a natural number (the slot). The state also carries the sender address, the contract's own address, and the EVM context fields `msg.value` and `block.timestamp`.

## ContractResult

```lean
inductive ContractResult (α : Type) where
  | success : α → ContractState → ContractResult α
  | revert : String → ContractState → ContractResult α
```

Every contract operation returns either `success` with a value and updated state, or `revert` with an error message and unchanged state. This makes `require` failures part of the type, so proofs can reason about both paths.

## Contract monad

```lean
abbrev Contract (α : Type) := ContractState → ContractResult α
```

A contract is a function from state to result. The custom `bind` short-circuits on revert:

```lean
def bind (ma : Contract α) (f : α → Contract β) : Contract β :=
  fun s => match ma s with
  | ContractResult.success a s' => f a s'
  | ContractResult.revert msg s' => ContractResult.revert msg s'
```

This gives do-notation with automatic failure propagation. A failed `require` stops the whole chain.

## Storage operations

```lean
def getStorage (s : StorageSlot Uint256) : Contract Uint256 :=
  fun state => ContractResult.success (state.storage s.slot) state

def setStorage (s : StorageSlot Uint256) (value : Uint256) : Contract Unit :=
  fun state => ContractResult.success ()
    { state with storage := fun slot =>
        if slot == s.slot then value else state.storage slot }
```

Address storage (`getStorageAddr`/`setStorageAddr`) and mapping storage (`getMapping`/`setMapping`) follow the same pattern with their respective state fields.

## Require guard

```lean
def require (condition : Bool) (message : String) : Contract Unit :=
  fun s => if condition
           then ContractResult.success () s
           else ContractResult.revert message s
```

Returns `success` when the condition holds, `revert` with the message when it doesn't.

## Simp lemmas

The core includes `@[simp]` lemmas for every storage operation:

```lean
@[simp] theorem require_true (msg : String) (s : ContractState) :
  (require true msg).run s = ContractResult.success () s := by rfl

@[simp] theorem require_false (msg : String) (s : ContractState) :
  (require false msg).run s = ContractResult.revert msg s := by rfl

@[simp] theorem getStorage_run_fst (slot : StorageSlot Uint256) (s : ContractState) :
  (getStorage slot).run s |>.fst = s.storage slot.slot := by rfl
```

These power the proofs. Most simple properties can be proven by `simp only [...]` with the right set of definitions.

## Why ContractResult instead of StateM

The original core used `StateM ContractState α`. This was simpler but couldn't model `require` failures. Proofs had to assume guards passed (using axioms).

`ContractResult` makes success/failure explicit. Proofs can reason about both paths, and no axioms are needed. The cost is a small amount of extra infrastructure (the ContractResult type, custom bind, and simp lemmas).

## Core growth

| Iteration | Focus | What was added |
|-----------|-------|----------------|
| 1 (Bootstrap) | Minimal core | Initial core |
| 2 (Counter) | Counter spec | Nothing needed |
| 3 (Owned) | Ownership | Address storage |
| 4 (OwnedCounter) | Ownership + counter | Nothing needed |
| 5 (SafeCounter) | Guarded ops | Cleanup |
| 6 (Ledger) | Mapping storage | Mapping storage |
| 7 (SimpleToken) | Token contract | Nothing needed |
| 8 (Verification) | Proof support | ContractResult, bind, simp lemmas, EVM context |

Most implementation iterations needed no core changes. The verification step added proof infrastructure rather than new contract primitives.

## Type safety

The `StorageSlot α` type parameter prevents mixing storage types:

```lean
def owner : StorageSlot Address := ⟨0⟩
def count : StorageSlot Uint256 := ⟨1⟩
def balances : StorageSlot (Address → Uint256) := ⟨2⟩

-- These compile:
let value ← getStorage count              -- Uint256
let addr ← getStorageAddr owner           -- Address
let bal ← getMapping balances "0xAlice"   -- Uint256

-- This doesn't:
let wrong ← getStorage owner  -- Type error: owner is Address, not Uint256
```

## Source

[`Verity/Core.lean`](https://github.com/Th0rgal/verity/blob/main/Verity/Core.lean)
