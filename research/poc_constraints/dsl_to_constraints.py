#!/usr/bin/env python3
"""Minimal DSL -> Solidity constraint harness compiler.

Supported syntax (single contract, single spec):

contract Loan

spec update(address user, uint256 newCollateral, uint256 newDebt):
  ensure: debt[user] == 0 || collateral[user] * 1e18 >= debt[user] * minHealthFactor

Notes:
- Only `ensure:` with a single expression is supported.
- The spec name must match the implementation function name.
"""

from __future__ import annotations

import re
import sys
from dataclasses import dataclass
from pathlib import Path


@dataclass
class Spec:
    contract: str
    func_name: str
    params: str
    ensure: str


CONTRACT_RE = re.compile(r"^contract\s+(?P<name>[A-Za-z_][A-Za-z0-9_]*)\s*$")
SPEC_RE = re.compile(r"^spec\s+(?P<name>[A-Za-z_][A-Za-z0-9_]*)\((?P<params>.*)\):\s*$")
ENSURE_RE = re.compile(r"^ensure:\s*(?P<expr>.+)$")


def parse_spec(text: str) -> Spec:
    contract = None
    func_name = None
    params = None
    ensure = None

    for raw in text.splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        if contract is None:
            match = CONTRACT_RE.match(line)
            if match:
                contract = match.group("name")
                continue
        match = SPEC_RE.match(line)
        if match:
            func_name = match.group("name")
            params = match.group("params").strip()
            continue
        match = ENSURE_RE.match(line)
        if match:
            ensure = match.group("expr").strip()

    missing = [
        name
        for name, value in (
            ("contract", contract),
            ("spec", func_name),
            ("ensure", ensure),
        )
        if value is None
    ]
    if missing:
        raise ValueError(f"Missing required fields: {', '.join(missing)}")

    return Spec(contract=contract, func_name=func_name, params=params or "", ensure=ensure)


def render(spec: Spec) -> str:
    harness = f"{spec.contract}SpecHarness"
    return f"""// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// Generated by research/poc_constraints/dsl_to_constraints.py from specs/loan.dc

import {{{spec.contract}}} from "./{spec.contract}.sol";

contract {harness} is {spec.contract} {{
    constructor(uint256 minHealthFactor_) {spec.contract}(minHealthFactor_) {{}}

    function {spec.func_name}_spec({spec.params}) external {{
        super.{spec.func_name}({', '.join(_param_names(spec.params))});
        assert({spec.ensure});
    }}
}}
"""


def _param_names(params: str) -> list[str]:
    if not params.strip():
        return []
    parts = [p.strip() for p in params.split(",")]
    names = []
    for part in parts:
        tokens = [t for t in part.split(" ") if t]
        if not tokens:
            continue
        names.append(tokens[-1])
    return names


def main() -> int:
    if len(sys.argv) != 3:
        print("Usage: dsl_to_constraints.py <spec.dc> <output.sol>")
        return 1

    spec_path = Path(sys.argv[1])
    out_path = Path(sys.argv[2])
    text = spec_path.read_text(encoding="utf-8")

    spec = parse_spec(text)
    out_path.write_text(render(spec), encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
