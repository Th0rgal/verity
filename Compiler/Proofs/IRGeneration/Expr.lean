/-
  Expression Compilation Correctness (High-Level Approach)

  Since compileExpr is private in ContractSpec, we prove properties about the
  overall compilation and execution pipeline rather than individual expressions.

  Strategy: Prove that for simple contracts like SimpleStorage, the compiled IR
  produces the same results as the Spec interpreter.
-/

import Compiler.Proofs.IRGeneration.IRInterpreter
import Compiler.Proofs.IRGeneration.Conversions
import Compiler.Proofs.SpecInterpreter
import Compiler.ContractSpec
import Compiler.Specs
import DumbContracts.Core

namespace Compiler.Proofs.IRGeneration

open Compiler
open Compiler.Specs
open Compiler.ContractSpec
open Compiler.Yul
open DumbContracts
open DiffTestTypes

/-! ## Proof Strategy

Instead of proving expression compilation directly (since compileExpr is private),
we prove end-to-end correctness for complete contracts.

For SimpleStorage:
1. Compile spec to IR: `compile simpleStorageSpec selectors`
2. Show IR execution matches Spec execution for store/retrieve functions
3. Use this as a template for other contracts

This approach:
- Works with the actual API (public `compile` function)
- Validates the full pipeline (not just expressions)
- Is more maintainable (doesn't depend on internal implementation)
-/

/-! ## Concrete IR for SimpleStorage

We pin down the exact IR generated by `compile` for SimpleStorage. This avoids
reasoning about compiler internals while still proving the full pipeline.
-/

def simpleStorageIRContract : IRContract :=
  { name := "SimpleStorage"
    deploy := []
    functions := [
      { name := "store"
        selector := 0x6057361d
        params := [{ name := "value", ty := IRType.uint256 }]
        ret := IRType.unit
        body := [
          YulStmt.let_ "value" (YulExpr.call "calldataload" [YulExpr.lit 4]),
          YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 0, YulExpr.ident "value"]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "retrieve"
        selector := 0x2e64cec1
        params := []
        ret := IRType.uint256
        body := [
          YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 0]]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      }
    ]
    usesMapping := false }

@[simp] lemma compile_simpleStorageSpec :
    compile simpleStorageSpec [0x6057361d, 0x2e64cec1] = .ok simpleStorageIRContract := by
  rfl

@[simp] lemma specStorage_getSlot_setSlot_same (slot value : Nat) :
    (SpecStorage.empty.setSlot slot value).getSlot slot = value := by
  unfold SpecStorage.setSlot SpecStorage.getSlot SpecStorage.empty
  simp

@[simp] lemma specStorage_getSlot_setSlot_other (slot other value : Nat) :
    slot ≠ other →
    (SpecStorage.empty.setSlot slot value).getSlot other = 0 := by
  intro hne
  unfold SpecStorage.setSlot SpecStorage.getSlot SpecStorage.empty
  simp [hne]

/-! ## SimpleStorage: Store Function Correctness

Theorem: Executing the compiled IR for `store(value)` produces the same result
as interpreting the Spec for `store(value)`.
-/

/-- Store function: IR execution matches Spec execution -/
theorem simpleStorage_store_correct (value : Nat) (initialState : ContractState) :
  let spec := simpleStorageSpec
  let irContract := compile spec [0x6057361d, 0x2e64cec1]  -- store, retrieve selectors
  let sender := "test_sender"
  let tx : Transaction := {
    sender := sender
    functionName := "store"
    args := [value]
  }
  -- Create IR transaction
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x6057361d  -- store selector
    args := [value]
  }
  -- Execute both sides
  let specResult := interpretSpec spec (SpecStorage.empty) tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState SpecStorage.empty sender)
      -- Results should match
      resultsMatch ir.usesMapping [] irResult specResult initialState
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    simpleStorageIRContract, SpecStorage.empty, specStorageToIRState]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

/-! ## SimpleStorage: Retrieve Function Correctness -/

/-- Retrieve function: IR execution matches Spec execution -/
theorem simpleStorage_retrieve_correct (initialState : ContractState) :
  let spec := simpleStorageSpec
  let irContract := compile spec [0x6057361d, 0x2e64cec1]
  let sender := "test_sender"
  let tx : Transaction := {
    sender := sender
    functionName := "retrieve"
    args := []
  }
  -- Create IR transaction
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x2e64cec1  -- retrieve selector
    args := []
  }
  let specResult := interpretSpec spec (SpecStorage.empty) tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState SpecStorage.empty sender)
      resultsMatch ir.usesMapping [] irResult specResult initialState
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    simpleStorageIRContract, SpecStorage.empty, specStorageToIRState]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

/-! ## SimpleStorage: Retrieve with Pre-Initialized Storage -/

theorem simpleStorage_retrieve_correct_with_storage (storedValue : Nat) (initialState : ContractState) :
  let spec := simpleStorageSpec
  let irContract := compile spec [0x6057361d, 0x2e64cec1]
  let sender := "test_sender"
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "retrieve"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x2e64cec1
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult initialState
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    simpleStorageIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
    specStorageToIRState]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

/-! ## Counter: Concrete IR -/

def counterIRContract : IRContract :=
  { name := "Counter"
    deploy := []
    functions := [
      { name := "increment"
        selector := 0xd09de08a
        params := []
        ret := IRType.unit
        body := [
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.lit 0,
            YulExpr.call "add" [YulExpr.call "sload" [YulExpr.lit 0], YulExpr.lit (1 % (2 ^ 256))]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "decrement"
        selector := 0x2baeceb7
        params := []
        ret := IRType.unit
        body := [
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.lit 0,
            YulExpr.call "sub" [YulExpr.call "sload" [YulExpr.lit 0], YulExpr.lit (1 % (2 ^ 256))]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "getCount"
        selector := 0xa87d942c
        params := []
        ret := IRType.uint256
        body := [
          YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 0]]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      }
    ]
    usesMapping := false }

@[simp] lemma compile_counterSpec :
    compile counterSpec [0xd09de08a, 0x2baeceb7, 0xa87d942c] = .ok counterIRContract := by
  rfl

/-! ## Counter: Function Correctness -/

theorem counter_increment_correct (initialState : ContractState) :
  let spec := counterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let sender := "test_sender"
  let tx : Transaction := {
    sender := sender
    functionName := "increment"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xd09de08a
    args := []
  }
  let specResult := interpretSpec spec SpecStorage.empty tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState SpecStorage.empty sender)
      resultsMatch ir.usesMapping [] irResult specResult initialState
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    counterIRContract, SpecStorage.empty, specStorageToIRState,
    DumbContracts.Core.Uint256.modulus, evmModulus]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

/-! ## SafeCounter: Concrete IR -/

def safeCounterOverflowRevert : List YulStmt :=
  [
    YulStmt.expr (YulExpr.call "mstore" [
      YulExpr.lit 0,
      YulExpr.hex 0x08c379a000000000000000000000000000000000000000000000000000000000
    ]),
    YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 4, YulExpr.lit 32]),
    YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 36, YulExpr.lit 21]),
    YulStmt.expr (YulExpr.call "mstore" [
      YulExpr.lit 68,
      YulExpr.hex 0x4f766572666c6f7720696e20696e6372656d656e740000000000000000000000
    ]),
    YulStmt.expr (YulExpr.call "revert" [YulExpr.lit 0, YulExpr.lit 100])
  ]

def safeCounterUnderflowRevert : List YulStmt :=
  [
    YulStmt.expr (YulExpr.call "mstore" [
      YulExpr.lit 0,
      YulExpr.hex 0x08c379a000000000000000000000000000000000000000000000000000000000
    ]),
    YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 4, YulExpr.lit 32]),
    YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 36, YulExpr.lit 22]),
    YulStmt.expr (YulExpr.call "mstore" [
      YulExpr.lit 68,
      YulExpr.hex 0x556e646572666c6f7720696e2064656372656d656e7400000000000000000000
    ]),
    YulStmt.expr (YulExpr.call "revert" [YulExpr.lit 0, YulExpr.lit 100])
  ]

def safeCounterIRContract : IRContract :=
  { name := "SafeCounter"
    deploy := []
    functions := [
      { name := "increment"
        selector := 0xd09de08a
        params := []
        ret := IRType.unit
        body := [
          YulStmt.let_ "count" (YulExpr.call "sload" [YulExpr.lit 0]),
          YulStmt.let_ "newCount" (YulExpr.call "add" [
            YulExpr.ident "count",
            YulExpr.lit (1 % (2 ^ 256))
          ]),
          YulStmt.if_
            (YulExpr.call "iszero" [
              YulExpr.call "gt" [YulExpr.ident "newCount", YulExpr.ident "count"]
            ])
            safeCounterOverflowRevert,
          YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 0, YulExpr.ident "newCount"]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "decrement"
        selector := 0x2baeceb7
        params := []
        ret := IRType.unit
        body := [
          YulStmt.let_ "count" (YulExpr.call "sload" [YulExpr.lit 0]),
          YulStmt.if_
            (YulExpr.call "lt" [YulExpr.ident "count", YulExpr.lit (1 % (2 ^ 256))])
            safeCounterUnderflowRevert,
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.lit 0,
            YulExpr.call "sub" [YulExpr.ident "count", YulExpr.lit (1 % (2 ^ 256))]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "getCount"
        selector := 0xa87d942c
        params := []
        ret := IRType.uint256
        body := [
          YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 0]]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      }
    ]
    usesMapping := false }

@[simp] lemma compile_safeCounterSpec :
    compile safeCounterSpec [0xd09de08a, 0x2baeceb7, 0xa87d942c] = .ok safeCounterIRContract := by
  rfl

/-! ## SafeCounter: Function Correctness -/

theorem safeCounter_increment_correct (storedValue : Nat) (initialState : ContractState) :
  let spec := safeCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let sender := "test_sender"
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "increment"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xd09de08a
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult initialState
  | .error _ => False
  := by
  by_cases h : (storedValue + 1) % evmModulus > storedValue
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      safeCounterIRContract, safeCounterOverflowRevert, SpecStorage.empty, SpecStorage.setSlot,
      SpecStorage.getSlot, specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · simp [hslot]
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      safeCounterIRContract, safeCounterOverflowRevert, SpecStorage.empty, SpecStorage.setSlot,
      SpecStorage.getSlot, specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · simp [hslot]

theorem safeCounter_decrement_correct (storedValue : Nat) (initialState : ContractState) :
  let spec := safeCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let sender := "test_sender"
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "decrement"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x2baeceb7
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult initialState
  | .error _ => False
  := by
  by_cases h : storedValue < 1
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      safeCounterIRContract, safeCounterUnderflowRevert, SpecStorage.empty, SpecStorage.setSlot,
      SpecStorage.getSlot, specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · simp [hslot]
  · have hge : storedValue >= 1 := by
      exact Nat.not_lt.mp h
    simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      safeCounterIRContract, safeCounterUnderflowRevert, SpecStorage.empty, SpecStorage.setSlot,
      SpecStorage.getSlot, specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h, hge]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · simp [hslot]

theorem safeCounter_getCount_correct (storedValue : Nat) (initialState : ContractState) :
  let spec := safeCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let sender := "test_sender"
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "getCount"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xa87d942c
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult initialState
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    safeCounterIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
    specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

theorem counter_decrement_correct (initialState : ContractState) :
  let spec := counterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let sender := "test_sender"
  let tx : Transaction := {
    sender := sender
    functionName := "decrement"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x2baeceb7
    args := []
  }
  let specResult := interpretSpec spec SpecStorage.empty tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState SpecStorage.empty sender)
      resultsMatch ir.usesMapping [] irResult specResult initialState
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    counterIRContract, SpecStorage.empty, specStorageToIRState,
    DumbContracts.Core.Uint256.modulus, evmModulus]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

theorem counter_getCount_correct (storedValue : Nat) (initialState : ContractState) :
  let spec := counterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let sender := "test_sender"
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "getCount"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xa87d942c
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult initialState
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    counterIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
    specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

/-! ## General Preservation Theorem Template

For any contract, we want to prove:

```lean
theorem contract_preserves_semantics (spec : ContractSpec) (selectors : List Nat)
    (tx : Transaction) (state : ContractState) :
  match compile spec selectors with
  | .ok ir =>
      let selectorOpt := (spec.functions.zip selectors).find?
        (fun (f, _) => f.name == tx.functionName) |>.map (·.2)
      match selectorOpt with
      | some selector =>
          let irTx := transactionToIRTransaction tx selector
          let irState := contractStateToIRState addrs state
          let irResult := interpretIR ir irTx irState
          let specResult := interpretSpec spec (contractStateToSpecStorage state) tx
          resultsMatch ir.usesMapping [] irResult specResult state
      | none => True  -- Function not found, both should fail
  | .error _ => True  -- Compilation failed
```

This is the actual preservation property we want to prove.
-/

/-! ## Proof Plan

To prove the preservation theorem, we need:

**Step 1: Expression Equivalence** (conceptual)
- Show that compiled expressions evaluate to the same values
- Cannot access compileExpr directly, but can observe through function execution

**Step 2: Statement Equivalence**
- Show that compiled statements have the same effects on state
- Storage updates, returns, reverts match between IR and Spec

**Step 3: Function Equivalence**
- Show that compiled functions produce the same results
- Parameter passing, body execution, return values all match

**Step 4: Contract Equivalence**
- Compose function proofs to get full contract correctness
- Prove the main preservation theorem

**Current File Status**:
- Sets up the proof framework ✅
- Documents the high-level strategy ✅
- Proves SimpleStorage store/retrieve correctness ✅
- Proves Counter increment/decrement/getCount correctness ✅
- Ready to extend proofs to additional contracts ⚠️

**Next Steps for Completion**:
1. Extend to SafeCounter (overflow checks)
2. Handle more complex contracts (Owned, Ledger, etc.)

**Why This Approach Works**:
- Uses public API (compile function)
- Proves end-to-end correctness (what users care about)
- Compositional (prove simple contracts first, build up)
- Maintainable (doesn't depend on internal implementation details)

**Estimated Effort**:
- SimpleStorage proofs: ~50 lines (simple, 2 functions)
- Counter proofs: ~100 lines (arithmetic, 3 functions)
- General framework: ~50 lines (reusable infrastructure)
- Total for Phase 2: ~200 lines (matches original estimate)

This file establishes the verification framework for expression compilation
(indirectly through contract execution). The actual proofs will be added
incrementally, starting with SimpleStorage.
-/

end Compiler.Proofs.IRGeneration
