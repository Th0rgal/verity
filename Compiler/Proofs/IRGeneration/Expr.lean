/-
  Expression Compilation Correctness (High-Level Approach)

  Since compileExpr is private in ContractSpec, we prove properties about the
  overall compilation and execution pipeline rather than individual expressions.

  Strategy: Prove that for simple contracts like SimpleStorage, the compiled IR
  produces the same results as the Spec interpreter.
-/

import Compiler.Proofs.IRGeneration.IRInterpreter
import Compiler.Proofs.IRGeneration.Conversions
import DumbContracts.Proofs.Stdlib.SpecInterpreter
import Compiler.ContractSpec
import Compiler.Specs
import DumbContracts.Core

namespace Compiler.Proofs.IRGeneration

open Compiler
open Compiler.Specs
open Compiler.ContractSpec
open Compiler.Yul
open DumbContracts
open DiffTestTypes
open DumbContracts.Proofs.Stdlib.SpecInterpreter

/-! ## Proof Strategy

Instead of proving expression compilation directly (since compileExpr is private),
we prove end-to-end correctness for complete contracts.

For SimpleStorage:
1. Compile spec to IR: `compile simpleStorageSpec selectors`
2. Show IR execution matches Spec execution for store/retrieve functions
3. Use this as a template for other contracts

This approach:
- Works with the actual API (public `compile` function)
- Validates the full pipeline (not just expressions)
- Is more maintainable (doesn't depend on internal implementation)
-/

/-! ## Concrete IR for SimpleStorage

We pin down the exact IR generated by `compile` for SimpleStorage. This avoids
reasoning about compiler internals while still proving the full pipeline.
-/

def simpleStorageIRContract : IRContract :=
  { name := "SimpleStorage"
    deploy := []
    functions := [
      { name := "store"
        selector := 0x6057361d
        params := [{ name := "value", ty := IRType.uint256 }]
        ret := IRType.unit
        body := [
          YulStmt.let_ "value" (YulExpr.call "calldataload" [YulExpr.lit 4]),
          YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 0, YulExpr.ident "value"]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "retrieve"
        selector := 0x2e64cec1
        params := []
        ret := IRType.uint256
        body := [
          YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 0]]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      }
    ]
    usesMapping := false }

@[simp] lemma compile_simpleStorageSpec :
    compile simpleStorageSpec [0x6057361d, 0x2e64cec1] = .ok simpleStorageIRContract := by
  rfl

@[simp] lemma specStorage_getSlot_setSlot_same (slot value : Nat) :
    (SpecStorage.empty.setSlot slot value).getSlot slot = value := by
  unfold SpecStorage.setSlot SpecStorage.getSlot SpecStorage.empty
  simp

@[simp] lemma specStorage_getSlot_setSlot_other (slot other value : Nat) :
    slot ≠ other →
    (SpecStorage.empty.setSlot slot value).getSlot other = 0 := by
  intro hne
  unfold SpecStorage.setSlot SpecStorage.getSlot SpecStorage.empty
  simp [hne]

@[simp] lemma addressToNat_mask (addr : Address) :
    addressToNat addr &&& (2^160 - 1) = addressToNat addr := by
  have hpos : 0 < (2^160 : Nat) := by
    have hbase : 0 < (2 : Nat) := by decide
    exact pow_pos hbase 160
  have hlt : addressToNat addr < 2^160 := by
    unfold addressToNat Compiler.Hex.addressToNat
    cases h : Compiler.Hex.parseHexNat? addr with
    | some n =>
        simp [Compiler.Hex.addressToNat, h, Nat.mod_lt, hpos]
    | none =>
        simp [Compiler.Hex.addressToNat, h, Nat.mod_lt, hpos]
  calc
    addressToNat addr &&& (2^160 - 1) = addressToNat addr % 2^160 := by
      simpa using (Nat.and_two_pow_sub_one_eq_mod (addressToNat addr) 160)
    _ = addressToNat addr := by
      exact Nat.mod_eq_of_lt hlt

/-! ## SimpleStorage: Store Function Correctness

Theorem: Executing the compiled IR for `store(value)` produces the same result
as interpreting the Spec for `store(value)`.
-/

/-- Store function: IR execution matches Spec execution (general sender) -/
theorem simpleStorage_store_correct_with_sender (value : Nat) (sender : Address) :
  let spec := simpleStorageSpec
  let irContract := compile spec [0x6057361d, 0x2e64cec1]  -- store, retrieve selectors
  let tx : Transaction := {
    sender := sender
    functionName := "store"
    args := [value]
  }
  -- Create IR transaction
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x6057361d  -- store selector
    args := [value]
  }
  -- Execute both sides
  let specResult := interpretSpec spec (SpecStorage.empty) tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState SpecStorage.empty sender)
      -- Results should match
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    simpleStorageIRContract, SpecStorage.empty, specStorageToIRState]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

-- Backwards-compatible specialization for existing proofs.
theorem simpleStorage_store_correct (value : Nat) :
  let spec := simpleStorageSpec
  let irContract := compile spec [0x6057361d, 0x2e64cec1]  -- store, retrieve selectors
  let sender := "test_sender"
  let tx : Transaction := {
    sender := sender
    functionName := "store"
    args := [value]
  }
  -- Create IR transaction
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x6057361d  -- store selector
    args := [value]
  }
  -- Execute both sides
  let specResult := interpretSpec spec (SpecStorage.empty) tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState SpecStorage.empty sender)
      -- Results should match
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simpa using (simpleStorage_store_correct_with_sender value "test_sender")

/-! ## SimpleStorage: Retrieve Function Correctness -/

/-- Retrieve function: IR execution matches Spec execution (general sender) -/
theorem simpleStorage_retrieve_correct_with_sender (sender : Address) :
  let spec := simpleStorageSpec
  let irContract := compile spec [0x6057361d, 0x2e64cec1]
  let tx : Transaction := {
    sender := sender
    functionName := "retrieve"
    args := []
  }
  -- Create IR transaction
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x2e64cec1  -- retrieve selector
    args := []
  }
  let specResult := interpretSpec spec (SpecStorage.empty) tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState SpecStorage.empty sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    simpleStorageIRContract, SpecStorage.empty, specStorageToIRState]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

-- Backwards-compatible specialization for existing proofs.
theorem simpleStorage_retrieve_correct :
  let spec := simpleStorageSpec
  let irContract := compile spec [0x6057361d, 0x2e64cec1]
  let sender := "test_sender"
  let tx : Transaction := {
    sender := sender
    functionName := "retrieve"
    args := []
  }
  -- Create IR transaction
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x2e64cec1  -- retrieve selector
    args := []
  }
  let specResult := interpretSpec spec (SpecStorage.empty) tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState SpecStorage.empty sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simpa using (simpleStorage_retrieve_correct_with_sender "test_sender")

/-! ## SimpleStorage: Retrieve with Pre-Initialized Storage -/

theorem simpleStorage_retrieve_correct_with_storage (storedValue : Nat) :
  let spec := simpleStorageSpec
  let irContract := compile spec [0x6057361d, 0x2e64cec1]
  let sender := "test_sender"
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "retrieve"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x2e64cec1
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    simpleStorageIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
    specStorageToIRState]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

/-! ## Counter: Concrete IR -/

def counterIRContract : IRContract :=
  { name := "Counter"
    deploy := []
    functions := [
      { name := "increment"
        selector := 0xd09de08a
        params := []
        ret := IRType.unit
        body := [
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.lit 0,
            YulExpr.call "add" [YulExpr.call "sload" [YulExpr.lit 0], YulExpr.lit (1 % (2 ^ 256))]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "decrement"
        selector := 0x2baeceb7
        params := []
        ret := IRType.unit
        body := [
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.lit 0,
            YulExpr.call "sub" [YulExpr.call "sload" [YulExpr.lit 0], YulExpr.lit (1 % (2 ^ 256))]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "getCount"
        selector := 0xa87d942c
        params := []
        ret := IRType.uint256
        body := [
          YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 0]]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      }
    ]
    usesMapping := false }

@[simp] lemma compile_counterSpec :
    compile counterSpec [0xd09de08a, 0x2baeceb7, 0xa87d942c] = .ok counterIRContract := by
  rfl

/-! ## Counter: Function Correctness -/

theorem counter_increment_correct :
  let spec := counterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let sender := "test_sender"
  let tx : Transaction := {
    sender := sender
    functionName := "increment"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xd09de08a
    args := []
  }
  let specResult := interpretSpec spec SpecStorage.empty tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState SpecStorage.empty sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    counterIRContract, SpecStorage.empty, specStorageToIRState,
    DumbContracts.Core.Uint256.modulus, evmModulus]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

/-! ## SafeCounter: Concrete IR -/

def safeCounterOverflowRevert : List YulStmt :=
  [
    YulStmt.expr (YulExpr.call "mstore" [
      YulExpr.lit 0,
      YulExpr.hex 0x08c379a000000000000000000000000000000000000000000000000000000000
    ]),
    YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 4, YulExpr.lit 32]),
    YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 36, YulExpr.lit 21]),
    YulStmt.expr (YulExpr.call "mstore" [
      YulExpr.lit 68,
      YulExpr.hex 0x4f766572666c6f7720696e20696e6372656d656e740000000000000000000000
    ]),
    YulStmt.expr (YulExpr.call "revert" [YulExpr.lit 0, YulExpr.lit 100])
  ]

def safeCounterUnderflowRevert : List YulStmt :=
  [
    YulStmt.expr (YulExpr.call "mstore" [
      YulExpr.lit 0,
      YulExpr.hex 0x08c379a000000000000000000000000000000000000000000000000000000000
    ]),
    YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 4, YulExpr.lit 32]),
    YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 36, YulExpr.lit 22]),
    YulStmt.expr (YulExpr.call "mstore" [
      YulExpr.lit 68,
      YulExpr.hex 0x556e646572666c6f7720696e2064656372656d656e7400000000000000000000
    ]),
    YulStmt.expr (YulExpr.call "revert" [YulExpr.lit 0, YulExpr.lit 100])
  ]

def insufficientBalanceRevert : List YulStmt :=
  [
    YulStmt.expr (YulExpr.call "mstore" [
      YulExpr.lit 0,
      YulExpr.hex 0x08c379a000000000000000000000000000000000000000000000000000000000
    ]),
    YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 4, YulExpr.lit 32]),
    YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 36, YulExpr.lit 20]),
    YulStmt.expr (YulExpr.call "mstore" [
      YulExpr.lit 68,
      YulExpr.hex 0x496e73756666696369656e742062616c616e6365000000000000000000000000
    ]),
    YulStmt.expr (YulExpr.call "revert" [YulExpr.lit 0, YulExpr.lit 100])
  ]

def safeCounterIRContract : IRContract :=
  { name := "SafeCounter"
    deploy := []
    functions := [
      { name := "increment"
        selector := 0xd09de08a
        params := []
        ret := IRType.unit
        body := [
          YulStmt.let_ "count" (YulExpr.call "sload" [YulExpr.lit 0]),
          YulStmt.let_ "newCount" (YulExpr.call "add" [
            YulExpr.ident "count",
            YulExpr.lit (1 % (2 ^ 256))
          ]),
          YulStmt.if_
            (YulExpr.call "iszero" [
              YulExpr.call "gt" [YulExpr.ident "newCount", YulExpr.ident "count"]
            ])
            safeCounterOverflowRevert,
          YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 0, YulExpr.ident "newCount"]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "decrement"
        selector := 0x2baeceb7
        params := []
        ret := IRType.unit
        body := [
          YulStmt.let_ "count" (YulExpr.call "sload" [YulExpr.lit 0]),
          YulStmt.if_
            (YulExpr.call "lt" [YulExpr.ident "count", YulExpr.lit (1 % (2 ^ 256))])
            safeCounterUnderflowRevert,
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.lit 0,
            YulExpr.call "sub" [YulExpr.ident "count", YulExpr.lit (1 % (2 ^ 256))]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "getCount"
        selector := 0xa87d942c
        params := []
        ret := IRType.uint256
        body := [
          YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 0]]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      }
    ]
    usesMapping := false }

@[simp] lemma compile_safeCounterSpec :
    compile safeCounterSpec [0xd09de08a, 0x2baeceb7, 0xa87d942c] = .ok safeCounterIRContract := by
  rfl

/-! ## SafeCounter: Function Correctness -/

theorem safeCounter_increment_correct_with_sender (storedValue : Nat) (sender : Address) :
  let spec := safeCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "increment"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xd09de08a
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  by_cases h : (storedValue + 1) % evmModulus > storedValue
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      safeCounterIRContract, safeCounterOverflowRevert, SpecStorage.empty, SpecStorage.setSlot,
      SpecStorage.getSlot, specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · simp [hslot]
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      safeCounterIRContract, safeCounterOverflowRevert, SpecStorage.empty, SpecStorage.setSlot,
      SpecStorage.getSlot, specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · simp [hslot]

-- Backwards-compatible specialization for existing proofs.
theorem safeCounter_increment_correct (storedValue : Nat) :
  let spec := safeCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let sender := "test_sender"
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "increment"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xd09de08a
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simpa using (safeCounter_increment_correct_with_sender storedValue "test_sender")

theorem safeCounter_decrement_correct_with_sender (storedValue : Nat) (sender : Address) :
  let spec := safeCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "decrement"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x2baeceb7
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  by_cases h : storedValue < 1
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      safeCounterIRContract, safeCounterUnderflowRevert, SpecStorage.empty, SpecStorage.setSlot,
      SpecStorage.getSlot, specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · simp [hslot]
  · have hge : storedValue >= 1 := by
      exact Nat.not_lt.mp h
    simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      safeCounterIRContract, safeCounterUnderflowRevert, SpecStorage.empty, SpecStorage.setSlot,
      SpecStorage.getSlot, specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h, hge]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · simp [hslot]

-- Backwards-compatible specialization for existing proofs.
theorem safeCounter_decrement_correct (storedValue : Nat) :
  let spec := safeCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let sender := "test_sender"
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "decrement"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x2baeceb7
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simpa using (safeCounter_decrement_correct_with_sender storedValue "test_sender")

theorem safeCounter_getCount_correct_with_sender (storedValue : Nat) (sender : Address) :
  let spec := safeCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "getCount"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xa87d942c
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    safeCounterIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
    specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

-- Backwards-compatible specialization for existing proofs.
theorem safeCounter_getCount_correct (storedValue : Nat) :
  let spec := safeCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let sender := "test_sender"
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "getCount"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xa87d942c
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simpa using (safeCounter_getCount_correct_with_sender storedValue "test_sender")

/-! ## SafeCounter: Contract-Level Preservation (Dispatch) -/

theorem safeCounter_contract_preserves_semantics (storedValue : Nat) (tx : Transaction) :
  let spec := safeCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      match tx.functionName, tx.args with
      | "increment", [] =>
          let irTx := transactionToIRTransaction tx 0xd09de08a
          let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
          resultsMatch ir.usesMapping [] irResult specResult
      | "decrement", [] =>
          let irTx := transactionToIRTransaction tx 0x2baeceb7
          let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
          resultsMatch ir.usesMapping [] irResult specResult
      | "getCount", [] =>
          let irTx := transactionToIRTransaction tx 0xa87d942c
          let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
          resultsMatch ir.usesMapping [] irResult specResult
      | _, _ => True
  | .error _ => False
  := by
  by_cases hinc : tx.functionName = "increment"
  · subst hinc
    cases hargs : tx.args with
    | nil =>
        simpa [hargs] using
          (safeCounter_increment_correct_with_sender storedValue tx.sender)
    | cons _ _ =>
        simp [hargs]
  · by_cases hdec : tx.functionName = "decrement"
    · subst hdec
      cases hargs : tx.args with
      | nil =>
          simpa [hargs] using
            (safeCounter_decrement_correct_with_sender storedValue tx.sender)
      | cons _ _ =>
          simp [hargs]
    · by_cases hget : tx.functionName = "getCount"
      · subst hget
        cases hargs : tx.args with
        | nil =>
            simpa [hargs] using
              (safeCounter_getCount_correct_with_sender storedValue tx.sender)
        | cons _ _ =>
            simp [hargs]
      · simp [hinc, hdec, hget]

theorem counter_decrement_correct :
  let spec := counterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let sender := "test_sender"
  let tx : Transaction := {
    sender := sender
    functionName := "decrement"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x2baeceb7
    args := []
  }
  let specResult := interpretSpec spec SpecStorage.empty tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState SpecStorage.empty sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    counterIRContract, SpecStorage.empty, specStorageToIRState,
    DumbContracts.Core.Uint256.modulus, evmModulus]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

theorem counter_getCount_correct (storedValue : Nat) :
  let spec := counterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c]
  let sender := "test_sender"
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedValue
  let tx : Transaction := {
    sender := sender
    functionName := "getCount"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xa87d942c
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    counterIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
    specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

/-! ## Owned: Concrete IR -/

def ownedNotOwnerRevert : List YulStmt :=
  [
    YulStmt.expr (YulExpr.call "mstore" [
      YulExpr.lit 0,
      YulExpr.hex 0x08c379a000000000000000000000000000000000000000000000000000000000
    ]),
    YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 4, YulExpr.lit 32]),
    YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 36, YulExpr.lit 9]),
    YulStmt.expr (YulExpr.call "mstore" [
      YulExpr.lit 68,
      YulExpr.hex 0x4e6f74206f776e65720000000000000000000000000000000000000000000000
    ]),
    YulStmt.expr (YulExpr.call "revert" [YulExpr.lit 0, YulExpr.lit 100])
  ]

def ownedIRContract : IRContract :=
  { name := "Owned"
    deploy := [
      YulStmt.let_ "argsOffset" (YulExpr.call "sub" [YulExpr.call "codesize" [], YulExpr.lit 32]),
      YulStmt.expr (YulExpr.call "codecopy" [YulExpr.lit 0, YulExpr.ident "argsOffset", YulExpr.lit 32]),
      YulStmt.let_ "arg0" (YulExpr.call "and" [
        YulExpr.call "mload" [YulExpr.lit 0],
        YulExpr.hex ((2^160) - 1)
      ]),
      YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 0, YulExpr.ident "arg0"])
    ]
    functions := [
      { name := "transferOwnership"
        selector := 0xf2fde38b
        params := [{ name := "newOwner", ty := IRType.address }]
        ret := IRType.unit
        body := [
          YulStmt.let_ "newOwner" (YulExpr.call "and" [
            YulExpr.call "calldataload" [YulExpr.lit 4],
            YulExpr.hex ((2^160) - 1)
          ]),
          YulStmt.if_
            (YulExpr.call "iszero" [
              YulExpr.call "eq" [
                YulExpr.call "caller" [],
                YulExpr.call "sload" [YulExpr.lit 0]
              ]
            ])
            ownedNotOwnerRevert,
          YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 0, YulExpr.ident "newOwner"]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "getOwner"
        selector := 0x893d20e8
        params := []
        ret := IRType.address
        body := [
          YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 0]]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      }
    ]
    usesMapping := false }

@[simp] lemma compile_ownedSpec :
    compile ownedSpec [0xf2fde38b, 0x893d20e8] = .ok ownedIRContract := by
  rfl

/-! ## Owned: Function Correctness -/

theorem owned_transferOwnership_correct_as_owner (newOwner : Nat) :
  let spec := ownedSpec
  let irContract := compile spec [0xf2fde38b, 0x893d20e8]
  let sender := "test_sender"
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 (addressToNat sender)
  let tx : Transaction := {
    sender := sender
    functionName := "transferOwnership"
    args := [newOwner]
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xf2fde38b
    args := [newOwner]
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    ownedIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
    specStorageToIRState]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

theorem owned_getOwner_correct (storedOwner : Nat) :
  let spec := ownedSpec
  let irContract := compile spec [0xf2fde38b, 0x893d20e8]
  let sender := "test_sender"
  let initialStorage : SpecStorage := SpecStorage.empty.setSlot 0 storedOwner
  let tx : Transaction := {
    sender := sender
    functionName := "getOwner"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x893d20e8
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    ownedIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
    specStorageToIRState]
  · intro slot
    by_cases h : slot = 0
    · subst h
      simp
    · simp [h]

/-! ## OwnedCounter: Concrete IR -/

def ownedCounterIRContract : IRContract :=
  { name := "OwnedCounter"
    deploy := [
      YulStmt.let_ "argsOffset" (YulExpr.call "sub" [YulExpr.call "codesize" [], YulExpr.lit 32]),
      YulStmt.expr (YulExpr.call "codecopy" [YulExpr.lit 0, YulExpr.ident "argsOffset", YulExpr.lit 32]),
      YulStmt.let_ "arg0" (YulExpr.call "and" [
        YulExpr.call "mload" [YulExpr.lit 0],
        YulExpr.hex ((2^160) - 1)
      ]),
      YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 0, YulExpr.ident "arg0"])
    ]
    functions := [
      { name := "increment"
        selector := 0xd09de08a
        params := []
        ret := IRType.unit
        body := [
          YulStmt.if_
            (YulExpr.call "iszero" [
              YulExpr.call "eq" [YulExpr.call "caller" [], YulExpr.call "sload" [YulExpr.lit 0]]
            ])
            ownedNotOwnerRevert,
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.lit 1,
            YulExpr.call "add" [YulExpr.call "sload" [YulExpr.lit 1], YulExpr.lit 1]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "decrement"
        selector := 0x2baeceb7
        params := []
        ret := IRType.unit
        body := [
          YulStmt.if_
            (YulExpr.call "iszero" [
              YulExpr.call "eq" [YulExpr.call "caller" [], YulExpr.call "sload" [YulExpr.lit 0]]
            ])
            ownedNotOwnerRevert,
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.lit 1,
            YulExpr.call "sub" [YulExpr.call "sload" [YulExpr.lit 1], YulExpr.lit 1]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "getCount"
        selector := 0xa87d942c
        params := []
        ret := IRType.uint256
        body := [
          YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 1]]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      },
      { name := "getOwner"
        selector := 0x893d20e8
        params := []
        ret := IRType.address
        body := [
          YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 0]]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      },
      { name := "transferOwnership"
        selector := 0xf2fde38b
        params := [{ name := "newOwner", ty := IRType.address }]
        ret := IRType.unit
        body := [
          YulStmt.let_ "newOwner" (YulExpr.call "and" [
            YulExpr.call "calldataload" [YulExpr.lit 4],
            YulExpr.hex ((2^160) - 1)
          ]),
          YulStmt.if_
            (YulExpr.call "iszero" [
              YulExpr.call "eq" [YulExpr.call "caller" [], YulExpr.call "sload" [YulExpr.lit 0]]
            ])
            ownedNotOwnerRevert,
          YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 0, YulExpr.ident "newOwner"]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      }
    ]
    usesMapping := false }

@[simp] lemma compile_ownedCounterSpec :
    compile ownedCounterSpec [0xd09de08a, 0x2baeceb7, 0xa87d942c, 0x893d20e8, 0xf2fde38b] =
      .ok ownedCounterIRContract := by
  rfl

/-! ## OwnedCounter: Function Correctness -/

theorem ownedCounter_increment_correct_with_sender (storedCount : Nat) (ownerAddr : Address)
    (sender : Address) :
  let spec := ownedCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c, 0x893d20e8, 0xf2fde38b]
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 1 storedCount
  let tx : Transaction := {
    sender := sender
    functionName := "increment"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xd09de08a
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  by_cases h : addressToNat sender = addressToNat ownerAddr
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      ownedCounterIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
      specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · by_cases hslot' : slot = 1
        · subst hslot'
          simp [hslot]
        · simp [hslot, hslot']
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      ownedCounterIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
      specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · by_cases hslot' : slot = 1
        · subst hslot'
          simp [hslot]
        · simp [hslot, hslot']

-- Backwards-compatible specialization for existing proofs.
theorem ownedCounter_increment_correct (storedCount : Nat) (ownerAddr : Address) :
  let spec := ownedCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c, 0x893d20e8, 0xf2fde38b]
  let sender := "test_sender"
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 1 storedCount
  let tx : Transaction := {
    sender := sender
    functionName := "increment"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xd09de08a
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simpa using (ownedCounter_increment_correct_with_sender storedCount ownerAddr "test_sender")

theorem ownedCounter_decrement_correct_with_sender (storedCount : Nat) (ownerAddr : Address)
    (sender : Address) :
  let spec := ownedCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c, 0x893d20e8, 0xf2fde38b]
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 1 storedCount
  let tx : Transaction := {
    sender := sender
    functionName := "decrement"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x2baeceb7
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  by_cases h : addressToNat sender = addressToNat ownerAddr
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      ownedCounterIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
      specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · by_cases hslot' : slot = 1
        · subst hslot'
          simp [hslot]
        · simp [hslot, hslot']
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      ownedCounterIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
      specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · by_cases hslot' : slot = 1
        · subst hslot'
          simp [hslot]
        · simp [hslot, hslot']

-- Backwards-compatible specialization for existing proofs.
theorem ownedCounter_decrement_correct (storedCount : Nat) (ownerAddr : Address) :
  let spec := ownedCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c, 0x893d20e8, 0xf2fde38b]
  let sender := "test_sender"
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 1 storedCount
  let tx : Transaction := {
    sender := sender
    functionName := "decrement"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x2baeceb7
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simpa using (ownedCounter_decrement_correct_with_sender storedCount ownerAddr "test_sender")

theorem ownedCounter_getCount_correct_with_sender (storedCount : Nat) (ownerAddr : Address)
    (sender : Address) :
  let spec := ownedCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c, 0x893d20e8, 0xf2fde38b]
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 1 storedCount
  let tx : Transaction := {
    sender := sender
    functionName := "getCount"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xa87d942c
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    ownedCounterIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
    specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus]
  · intro slot
    by_cases hslot : slot = 0
    · subst hslot
      simp
    · by_cases hslot' : slot = 1
      · subst hslot'
        simp [hslot]
      · simp [hslot, hslot']

-- Backwards-compatible specialization for existing proofs.
theorem ownedCounter_getCount_correct (storedCount : Nat) (ownerAddr : Address) :
  let spec := ownedCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c, 0x893d20e8, 0xf2fde38b]
  let sender := "test_sender"
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 1 storedCount
  let tx : Transaction := {
    sender := sender
    functionName := "getCount"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xa87d942c
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simpa using (ownedCounter_getCount_correct_with_sender storedCount ownerAddr "test_sender")

theorem ownedCounter_getOwner_correct_with_sender (storedOwner : Nat) (storedCount : Nat)
    (sender : Address) :
  let spec := ownedCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c, 0x893d20e8, 0xf2fde38b]
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 storedOwner).setSlot 1 storedCount
  let tx : Transaction := {
    sender := sender
    functionName := "getOwner"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x893d20e8
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    ownedCounterIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
    specStorageToIRState]
  · intro slot
    by_cases hslot : slot = 0
    · subst hslot
      simp
    · by_cases hslot' : slot = 1
      · subst hslot'
        simp [hslot]
      · simp [hslot, hslot']

-- Backwards-compatible specialization for existing proofs.
theorem ownedCounter_getOwner_correct (storedOwner : Nat) (storedCount : Nat) :
  let spec := ownedCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c, 0x893d20e8, 0xf2fde38b]
  let sender := "test_sender"
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 storedOwner).setSlot 1 storedCount
  let tx : Transaction := {
    sender := sender
    functionName := "getOwner"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0x893d20e8
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simpa using (ownedCounter_getOwner_correct_with_sender storedOwner storedCount "test_sender")

theorem ownedCounter_transferOwnership_correct_with_sender (storedCount : Nat)
    (ownerAddr : Address) (newOwnerNat : Nat) (sender : Address) :
  let spec := ownedCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c, 0x893d20e8, 0xf2fde38b]
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 1 storedCount
  let tx : Transaction := {
    sender := sender
    functionName := "transferOwnership"
    args := [newOwnerNat]
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xf2fde38b
    args := [newOwnerNat]
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  by_cases h : addressToNat sender = addressToNat ownerAddr
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      ownedCounterIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
      specStorageToIRState, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · by_cases hslot' : slot = 1
        · subst hslot'
          simp [hslot]
        · simp [hslot, hslot']
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      ownedCounterIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
      specStorageToIRState, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · by_cases hslot' : slot = 1
        · subst hslot'
          simp [hslot]
        · simp [hslot, hslot']

-- Backwards-compatible specialization for existing proofs.
theorem ownedCounter_transferOwnership_correct (storedCount : Nat) (ownerAddr newOwnerAddr : Address)
    :
  let spec := ownedCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c, 0x893d20e8, 0xf2fde38b]
  let sender := "test_sender"
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 1 storedCount
  let tx : Transaction := {
    sender := sender
    functionName := "transferOwnership"
    args := [addressToNat newOwnerAddr]
  }
  let irTx : IRTransaction := {
    sender := addressToNat sender
    functionSelector := 0xf2fde38b
    args := [addressToNat newOwnerAddr]
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage sender)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simpa using
    (ownedCounter_transferOwnership_correct_with_sender
      storedCount ownerAddr (addressToNat newOwnerAddr) "test_sender")

/-! ## OwnedCounter: Contract-Level Preservation (Dispatch) -/

theorem ownedCounter_contract_preserves_semantics (storedCount : Nat) (ownerAddr : Address)
    (tx : Transaction) :
  let spec := ownedCounterSpec
  let irContract := compile spec [0xd09de08a, 0x2baeceb7, 0xa87d942c, 0x893d20e8, 0xf2fde38b]
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 1 storedCount
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      match tx.functionName, tx.args with
      | "increment", [] =>
          let irTx := transactionToIRTransaction tx 0xd09de08a
          let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
          resultsMatch ir.usesMapping [] irResult specResult
      | "decrement", [] =>
          let irTx := transactionToIRTransaction tx 0x2baeceb7
          let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
          resultsMatch ir.usesMapping [] irResult specResult
      | "getCount", [] =>
          let irTx := transactionToIRTransaction tx 0xa87d942c
          let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
          resultsMatch ir.usesMapping [] irResult specResult
      | "getOwner", [] =>
          let irTx := transactionToIRTransaction tx 0x893d20e8
          let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
          resultsMatch ir.usesMapping [] irResult specResult
      | "transferOwnership", [newOwner] =>
          let irTx := transactionToIRTransaction tx 0xf2fde38b
          let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
          resultsMatch ir.usesMapping [] irResult specResult
      | _, _ => True
  | .error _ => False
  := by
  by_cases hinc : tx.functionName = "increment"
  · subst hinc
    cases hargs : tx.args with
    | nil =>
        simpa [hargs] using
          (ownedCounter_increment_correct_with_sender storedCount ownerAddr tx.sender)
    | cons _ _ =>
        simp [hargs]
  · by_cases hdec : tx.functionName = "decrement"
    · subst hdec
      cases hargs : tx.args with
      | nil =>
          simpa [hargs] using
            (ownedCounter_decrement_correct_with_sender storedCount ownerAddr tx.sender)
      | cons _ _ =>
          simp [hargs]
    · by_cases hget : tx.functionName = "getCount"
      · subst hget
        cases hargs : tx.args with
        | nil =>
            simpa [hargs] using
              (ownedCounter_getCount_correct_with_sender storedCount ownerAddr tx.sender)
        | cons _ _ =>
            simp [hargs]
      · by_cases howner : tx.functionName = "getOwner"
        · subst howner
          cases hargs : tx.args with
          | nil =>
              simpa [hargs] using
                (ownedCounter_getOwner_correct_with_sender
                  (addressToNat ownerAddr) storedCount tx.sender)
          | cons _ _ =>
              simp [hargs]
        · by_cases htransfer : tx.functionName = "transferOwnership"
          · subst htransfer
            cases hargs : tx.args with
            | nil =>
                simp [hargs]
            | cons newOwner rest =>
                cases rest with
                | nil =>
                    simpa [hargs] using
                      (ownedCounter_transferOwnership_correct_with_sender
                        storedCount ownerAddr newOwner tx.sender)
                | cons _ _ =>
                    simp [hargs]
          · simp [hinc, hdec, hget, howner, htransfer]

/-! ## Ledger: Concrete IR -/

def ledgerIRContract : IRContract :=
  { name := "Ledger"
    deploy := []
    functions := [
      { name := "deposit"
        selector := 0xb6b55f25
        params := [{ name := "amount", ty := IRType.uint256 }]
        ret := IRType.unit
        body := [
          YulStmt.let_ "amount" (YulExpr.call "calldataload" [YulExpr.lit 4]),
          YulStmt.let_ "senderBal" (YulExpr.call "sload" [
            YulExpr.call "mappingSlot" [YulExpr.lit 0, YulExpr.call "caller" []]
          ]),
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.call "mappingSlot" [YulExpr.lit 0, YulExpr.call "caller" []],
            YulExpr.call "add" [YulExpr.ident "senderBal", YulExpr.ident "amount"]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "withdraw"
        selector := 0x2e1a7d4d
        params := [{ name := "amount", ty := IRType.uint256 }]
        ret := IRType.unit
        body := [
          YulStmt.let_ "amount" (YulExpr.call "calldataload" [YulExpr.lit 4]),
          YulStmt.let_ "senderBal" (YulExpr.call "sload" [
            YulExpr.call "mappingSlot" [YulExpr.lit 0, YulExpr.call "caller" []]
          ]),
          YulStmt.if_
            (YulExpr.call "lt" [YulExpr.ident "senderBal", YulExpr.ident "amount"])
            insufficientBalanceRevert,
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.call "mappingSlot" [YulExpr.lit 0, YulExpr.call "caller" []],
            YulExpr.call "sub" [YulExpr.ident "senderBal", YulExpr.ident "amount"]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "transfer"
        selector := 0xa9059cbb
        params := [{ name := "to", ty := IRType.address }, { name := "amount", ty := IRType.uint256 }]
        ret := IRType.unit
        body := [
          YulStmt.let_ "to" (YulExpr.call "and" [
            YulExpr.call "calldataload" [YulExpr.lit 4],
            YulExpr.hex ((2^160) - 1)
          ]),
          YulStmt.let_ "amount" (YulExpr.call "calldataload" [YulExpr.lit 36]),
          YulStmt.let_ "senderBal" (YulExpr.call "sload" [
            YulExpr.call "mappingSlot" [YulExpr.lit 0, YulExpr.call "caller" []]
          ]),
          YulStmt.let_ "recipientBal" (YulExpr.call "sload" [
            YulExpr.call "mappingSlot" [YulExpr.lit 0, YulExpr.ident "to"]
          ]),
          YulStmt.if_
            (YulExpr.call "lt" [YulExpr.ident "senderBal", YulExpr.ident "amount"])
            insufficientBalanceRevert,
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.call "mappingSlot" [YulExpr.lit 0, YulExpr.call "caller" []],
            YulExpr.call "sub" [YulExpr.ident "senderBal", YulExpr.ident "amount"]
          ]),
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.call "mappingSlot" [YulExpr.lit 0, YulExpr.ident "to"],
            YulExpr.call "add" [YulExpr.ident "recipientBal", YulExpr.ident "amount"]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "getBalance"
        selector := 0xf8b2cb4f
        params := [{ name := "addr", ty := IRType.address }]
        ret := IRType.uint256
        body := [
          YulStmt.let_ "addr" (YulExpr.call "and" [
            YulExpr.call "calldataload" [YulExpr.lit 4],
            YulExpr.hex ((2^160) - 1)
          ]),
          YulStmt.expr (YulExpr.call "mstore" [
            YulExpr.lit 0,
            YulExpr.call "sload" [
              YulExpr.call "mappingSlot" [YulExpr.lit 0, YulExpr.ident "addr"]
            ]
          ]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      }
    ]
    usesMapping := true }

@[simp] lemma compile_ledgerSpec :
    compile ledgerSpec [0xb6b55f25, 0x2e1a7d4d, 0xa9059cbb, 0xf8b2cb4f] = .ok ledgerIRContract := by
  rfl

/-! ## Ledger: Function Correctness -/

theorem ledger_deposit_correct (senderBal amount : Nat) (senderAddr : Address) :
  let spec := ledgerSpec
  let irContract := compile spec [0xb6b55f25, 0x2e1a7d4d, 0xa9059cbb, 0xf8b2cb4f]
  let initialStorage : SpecStorage :=
    SpecStorage.empty.setMapping 0 (addressToNat senderAddr) senderBal
  let tx : Transaction := {
    sender := senderAddr
    functionName := "deposit"
    args := [amount]
  }
  let irTx : IRTransaction := {
    sender := addressToNat senderAddr
    functionSelector := 0xb6b55f25
    args := [amount]
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage senderAddr)
      resultsMatch ir.usesMapping [senderAddr] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    ledgerIRContract, SpecStorage.empty, SpecStorage.setMapping, SpecStorage.getMapping,
    specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus]
  · intro slot
    simp
  · intro baseSlot addr haddr
    simp at haddr
    subst haddr
    simp

theorem ledger_withdraw_correct (senderBal amount : Nat) (senderAddr : Address) :
  let spec := ledgerSpec
  let irContract := compile spec [0xb6b55f25, 0x2e1a7d4d, 0xa9059cbb, 0xf8b2cb4f]
  let initialStorage : SpecStorage :=
    SpecStorage.empty.setMapping 0 (addressToNat senderAddr) senderBal
  let tx : Transaction := {
    sender := senderAddr
    functionName := "withdraw"
    args := [amount]
  }
  let irTx : IRTransaction := {
    sender := addressToNat senderAddr
    functionSelector := 0x2e1a7d4d
    args := [amount]
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage senderAddr)
      resultsMatch ir.usesMapping [senderAddr] irResult specResult
  | .error _ => False
  := by
  by_cases h : senderBal < amount
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      ledgerIRContract, insufficientBalanceRevert, SpecStorage.empty, SpecStorage.setMapping,
      SpecStorage.getMapping, specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      simp
    · intro baseSlot addr haddr
      simp at haddr
      subst haddr
      simp
  · have hge : senderBal ≥ amount := by
      exact Nat.not_lt.mp h
    simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      ledgerIRContract, insufficientBalanceRevert, SpecStorage.empty, SpecStorage.setMapping,
      SpecStorage.getMapping, specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h, hge]
    · intro slot
      simp
    · intro baseSlot addr haddr
      simp at haddr
      subst haddr
      simp

theorem ledger_transfer_correct (senderBal recipientBal amount : Nat)
    (senderAddr recipientAddr : Address) :
  let spec := ledgerSpec
  let irContract := compile spec [0xb6b55f25, 0x2e1a7d4d, 0xa9059cbb, 0xf8b2cb4f]
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setMapping 0 (addressToNat senderAddr) senderBal)
      .setMapping 0 (addressToNat recipientAddr) recipientBal
  let tx : Transaction := {
    sender := senderAddr
    functionName := "transfer"
    args := [addressToNat recipientAddr, amount]
  }
  let irTx : IRTransaction := {
    sender := addressToNat senderAddr
    functionSelector := 0xa9059cbb
    args := [addressToNat recipientAddr, amount]
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage senderAddr)
      resultsMatch ir.usesMapping [senderAddr, recipientAddr] irResult specResult
  | .error _ => False
  := by
  by_cases h : senderBal < amount
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      ledgerIRContract, insufficientBalanceRevert, SpecStorage.empty, SpecStorage.setMapping,
      SpecStorage.getMapping, specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      simp
    · intro baseSlot addr haddr
      simp at haddr
      rcases haddr with rfl | rfl
      · simp
      · simp
  · have hge : senderBal ≥ amount := by
      exact Nat.not_lt.mp h
    simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      ledgerIRContract, insufficientBalanceRevert, SpecStorage.empty, SpecStorage.setMapping,
      SpecStorage.getMapping, specStorageToIRState, DumbContracts.Core.Uint256.modulus, evmModulus, h, hge]
    · intro slot
      simp
    · intro baseSlot addr haddr
      simp at haddr
      rcases haddr with rfl | rfl
      · simp
      · simp

theorem ledger_getBalance_correct (storedBal : Nat) (addr : Address) (senderAddr : Address)
    :
  let spec := ledgerSpec
  let irContract := compile spec [0xb6b55f25, 0x2e1a7d4d, 0xa9059cbb, 0xf8b2cb4f]
  let initialStorage : SpecStorage :=
    SpecStorage.empty.setMapping 0 (addressToNat addr) storedBal
  let tx : Transaction := {
    sender := senderAddr
    functionName := "getBalance"
    args := [addressToNat addr]
  }
  let irTx : IRTransaction := {
    sender := addressToNat senderAddr
    functionSelector := 0xf8b2cb4f
    args := [addressToNat addr]
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage senderAddr)
      resultsMatch ir.usesMapping [addr] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    ledgerIRContract, SpecStorage.empty, SpecStorage.setMapping, SpecStorage.getMapping,
    specStorageToIRState]
  · intro slot
    simp
  · intro baseSlot addr' haddr
    simp at haddr
    subst haddr
    simp

/-! ## Ledger: Contract-Level Preservation (Dispatch) -/

theorem ledger_contract_preserves_semantics (senderBal recipientBal storedBal : Nat)
    (recipientAddr balanceAddr : Address) (tx : Transaction) :
  let spec := ledgerSpec
  let irContract := compile spec [0xb6b55f25, 0x2e1a7d4d, 0xa9059cbb, 0xf8b2cb4f]
  match irContract with
  | .ok ir =>
      match tx.functionName, tx.args with
      | "deposit", [amount] =>
          let initialStorage : SpecStorage :=
            SpecStorage.empty.setMapping 0 (addressToNat tx.sender) senderBal
          let specResult := interpretSpec spec initialStorage tx
          let irTx := transactionToIRTransaction tx 0xb6b55f25
          let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
          resultsMatch ir.usesMapping [tx.sender] irResult specResult
      | "withdraw", [amount] =>
          let initialStorage : SpecStorage :=
            SpecStorage.empty.setMapping 0 (addressToNat tx.sender) senderBal
          let specResult := interpretSpec spec initialStorage tx
          let irTx := transactionToIRTransaction tx 0x2e1a7d4d
          let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
          resultsMatch ir.usesMapping [tx.sender] irResult specResult
      | "transfer", [recipient, amount] =>
          if recipient = addressToNat recipientAddr then
            let initialStorage : SpecStorage :=
              (SpecStorage.empty.setMapping 0 (addressToNat tx.sender) senderBal)
                .setMapping 0 (addressToNat recipientAddr) recipientBal
            let specResult := interpretSpec spec initialStorage tx
            let irTx := transactionToIRTransaction tx 0xa9059cbb
            let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
            resultsMatch ir.usesMapping [tx.sender, recipientAddr] irResult specResult
          else
            True
      | "getBalance", [addr] =>
          if addr = addressToNat balanceAddr then
            let initialStorage : SpecStorage :=
              SpecStorage.empty.setMapping 0 (addressToNat balanceAddr) storedBal
            let specResult := interpretSpec spec initialStorage tx
            let irTx := transactionToIRTransaction tx 0xf8b2cb4f
            let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
            resultsMatch ir.usesMapping [balanceAddr] irResult specResult
          else
            True
      | _, _ => True
  | .error _ => False
  := by
  by_cases hdep : tx.functionName = "deposit"
  · subst hdep
    cases hargs : tx.args with
    | nil =>
        simp [hargs]
    | cons amount rest =>
        cases rest with
        | nil =>
            simpa [hargs] using (ledger_deposit_correct senderBal amount tx.sender)
        | cons _ _ =>
            simp [hargs]
  · by_cases hwith : tx.functionName = "withdraw"
    · subst hwith
      cases hargs : tx.args with
      | nil =>
          simp [hargs]
      | cons amount rest =>
          cases rest with
          | nil =>
              simpa [hargs] using (ledger_withdraw_correct senderBal amount tx.sender)
          | cons _ _ =>
              simp [hargs]
    · by_cases htrans : tx.functionName = "transfer"
      · subst htrans
        cases hargs : tx.args with
        | nil =>
            simp [hargs]
        | cons recipient rest =>
            cases rest with
            | nil =>
                simp [hargs]
            | cons amount tail =>
                cases tail with
                | nil =>
                    by_cases haddr : recipient = addressToNat recipientAddr
                    · simpa [hargs, haddr] using
                        (ledger_transfer_correct senderBal recipientBal amount tx.sender recipientAddr)
                    · simp [hargs, haddr]
                | cons _ _ =>
                    simp [hargs]
      · by_cases hget : tx.functionName = "getBalance"
        · subst hget
          cases hargs : tx.args with
          | nil =>
              simp [hargs]
          | cons addr rest =>
              cases rest with
              | nil =>
                  by_cases haddr : addr = addressToNat balanceAddr
                  · simpa [hargs, haddr] using
                      (ledger_getBalance_correct storedBal balanceAddr tx.sender)
                  · simp [hargs, haddr]
              | cons _ _ =>
                  simp [hargs]
        · simp [hdep, hwith, htrans, hget]

/-! ## SimpleToken: Concrete IR -/

def simpleTokenIRContract : IRContract :=
  { name := "SimpleToken"
    deploy := [
      YulStmt.let_ "argsOffset" (YulExpr.call "sub" [YulExpr.call "codesize" [], YulExpr.lit 32]),
      YulStmt.expr (YulExpr.call "codecopy" [YulExpr.lit 0, YulExpr.ident "argsOffset", YulExpr.lit 32]),
      YulStmt.let_ "arg0" (YulExpr.call "and" [
        YulExpr.call "mload" [YulExpr.lit 0],
        YulExpr.hex ((2^160) - 1)
      ]),
      YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 0, YulExpr.ident "arg0"]),
      YulStmt.expr (YulExpr.call "sstore" [YulExpr.lit 2, YulExpr.lit 0])
    ]
    functions := [
      { name := "mint"
        selector := 0x40c10f19
        params := [{ name := "to", ty := IRType.address }, { name := "amount", ty := IRType.uint256 }]
        ret := IRType.unit
        body := [
          YulStmt.let_ "to" (YulExpr.call "and" [
            YulExpr.call "calldataload" [YulExpr.lit 4],
            YulExpr.hex ((2^160) - 1)
          ]),
          YulStmt.let_ "amount" (YulExpr.call "calldataload" [YulExpr.lit 36]),
          YulStmt.if_
            (YulExpr.call "iszero" [
              YulExpr.call "eq" [YulExpr.call "caller" [], YulExpr.call "sload" [YulExpr.lit 0]]
            ])
            ownedNotOwnerRevert,
          YulStmt.let_ "recipientBal" (YulExpr.call "sload" [
            YulExpr.call "mappingSlot" [YulExpr.lit 1, YulExpr.ident "to"]
          ]),
          YulStmt.let_ "supply" (YulExpr.call "sload" [YulExpr.lit 2]),
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.call "mappingSlot" [YulExpr.lit 1, YulExpr.ident "to"],
            YulExpr.call "add" [YulExpr.ident "recipientBal", YulExpr.ident "amount"]
          ]),
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.lit 2,
            YulExpr.call "add" [YulExpr.ident "supply", YulExpr.ident "amount"]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "transfer"
        selector := 0xa9059cbb
        params := [{ name := "to", ty := IRType.address }, { name := "amount", ty := IRType.uint256 }]
        ret := IRType.unit
        body := [
          YulStmt.let_ "to" (YulExpr.call "and" [
            YulExpr.call "calldataload" [YulExpr.lit 4],
            YulExpr.hex ((2^160) - 1)
          ]),
          YulStmt.let_ "amount" (YulExpr.call "calldataload" [YulExpr.lit 36]),
          YulStmt.let_ "senderBal" (YulExpr.call "sload" [
            YulExpr.call "mappingSlot" [YulExpr.lit 1, YulExpr.call "caller" []]
          ]),
          YulStmt.let_ "recipientBal" (YulExpr.call "sload" [
            YulExpr.call "mappingSlot" [YulExpr.lit 1, YulExpr.ident "to"]
          ]),
          YulStmt.if_
            (YulExpr.call "lt" [YulExpr.ident "senderBal", YulExpr.ident "amount"])
            insufficientBalanceRevert,
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.call "mappingSlot" [YulExpr.lit 1, YulExpr.call "caller" []],
            YulExpr.call "sub" [YulExpr.ident "senderBal", YulExpr.ident "amount"]
          ]),
          YulStmt.expr (YulExpr.call "sstore" [
            YulExpr.call "mappingSlot" [YulExpr.lit 1, YulExpr.ident "to"],
            YulExpr.call "add" [YulExpr.ident "recipientBal", YulExpr.ident "amount"]
          ]),
          YulStmt.expr (YulExpr.call "stop" [])
        ]
      },
      { name := "balanceOf"
        selector := 0x70a08231
        params := [{ name := "addr", ty := IRType.address }]
        ret := IRType.uint256
        body := [
          YulStmt.let_ "addr" (YulExpr.call "and" [
            YulExpr.call "calldataload" [YulExpr.lit 4],
            YulExpr.hex ((2^160) - 1)
          ]),
          YulStmt.expr (YulExpr.call "mstore" [
            YulExpr.lit 0,
            YulExpr.call "sload" [
              YulExpr.call "mappingSlot" [YulExpr.lit 1, YulExpr.ident "addr"]
            ]
          ]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      },
      { name := "totalSupply"
        selector := 0x18160ddd
        params := []
        ret := IRType.uint256
        body := [
          YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 2]]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      },
      { name := "owner"
        selector := 0x8da5cb5b
        params := []
        ret := IRType.address
        body := [
          YulStmt.expr (YulExpr.call "mstore" [YulExpr.lit 0, YulExpr.call "sload" [YulExpr.lit 0]]),
          YulStmt.expr (YulExpr.call "return" [YulExpr.lit 0, YulExpr.lit 32])
        ]
      }
    ]
    usesMapping := true }

@[simp] lemma compile_simpleTokenSpec :
    compile simpleTokenSpec [0x40c10f19, 0xa9059cbb, 0x70a08231, 0x18160ddd, 0x8da5cb5b] =
      .ok simpleTokenIRContract := by
  rfl

/-! ## SimpleToken: Function Correctness -/

theorem simpleToken_mint_correct (senderBal totalSupply amount : Nat) (senderAddr toAddr ownerAddr : Address)
    :
  let spec := simpleTokenSpec
  let irContract := compile spec [0x40c10f19, 0xa9059cbb, 0x70a08231, 0x18160ddd, 0x8da5cb5b]
  let initialStorage : SpecStorage :=
    ((SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 2 totalSupply)
      .setMapping 1 (addressToNat toAddr) senderBal
  let tx : Transaction := {
    sender := senderAddr
    functionName := "mint"
    args := [addressToNat toAddr, amount]
  }
  let irTx : IRTransaction := {
    sender := addressToNat senderAddr
    functionSelector := 0x40c10f19
    args := [addressToNat toAddr, amount]
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage senderAddr)
      resultsMatch ir.usesMapping [toAddr] irResult specResult
  | .error _ => False
  := by
  by_cases h : addressToNat senderAddr = addressToNat ownerAddr
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      simpleTokenIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.setMapping,
      SpecStorage.getSlot, SpecStorage.getMapping, specStorageToIRState,
      DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · by_cases hslot' : slot = 2
        · subst hslot'
          simp [hslot]
        · simp [hslot, hslot']
    · intro baseSlot addr haddr
      simp at haddr
      subst haddr
      simp
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      simpleTokenIRContract, ownedNotOwnerRevert, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.setMapping,
      SpecStorage.getSlot, SpecStorage.getMapping, specStorageToIRState,
      DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · by_cases hslot' : slot = 2
        · subst hslot'
          simp [hslot]
        · simp [hslot, hslot']
    · intro baseSlot addr haddr
      simp at haddr
      subst haddr
      simp

theorem simpleToken_transfer_correct (senderBal recipientBal totalSupply amount : Nat)
    (senderAddr recipientAddr ownerAddr : Address) :
  let spec := simpleTokenSpec
  let irContract := compile spec [0x40c10f19, 0xa9059cbb, 0x70a08231, 0x18160ddd, 0x8da5cb5b]
  let initialStorage : SpecStorage :=
    (((SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 2 totalSupply)
      .setMapping 1 (addressToNat senderAddr) senderBal)
      .setMapping 1 (addressToNat recipientAddr) recipientBal
  let tx : Transaction := {
    sender := senderAddr
    functionName := "transfer"
    args := [addressToNat recipientAddr, amount]
  }
  let irTx : IRTransaction := {
    sender := addressToNat senderAddr
    functionSelector := 0xa9059cbb
    args := [addressToNat recipientAddr, amount]
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage senderAddr)
      resultsMatch ir.usesMapping [senderAddr, recipientAddr] irResult specResult
  | .error _ => False
  := by
  by_cases h : senderBal < amount
  · simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      simpleTokenIRContract, insufficientBalanceRevert, SpecStorage.empty, SpecStorage.setSlot,
      SpecStorage.setMapping, SpecStorage.getSlot, SpecStorage.getMapping, specStorageToIRState,
      DumbContracts.Core.Uint256.modulus, evmModulus, h]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · by_cases hslot' : slot = 2
        · subst hslot'
          simp [hslot]
        · simp [hslot, hslot']
    · intro baseSlot addr haddr
      simp at haddr
      rcases haddr with rfl | rfl
      · simp
      · simp
  · have hge : senderBal ≥ amount := by
      exact Nat.not_lt.mp h
    simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
      interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
      simpleTokenIRContract, insufficientBalanceRevert, SpecStorage.empty, SpecStorage.setSlot,
      SpecStorage.setMapping, SpecStorage.getSlot, SpecStorage.getMapping, specStorageToIRState,
      DumbContracts.Core.Uint256.modulus, evmModulus, h, hge]
    · intro slot
      by_cases hslot : slot = 0
      · subst hslot
        simp
      · by_cases hslot' : slot = 2
        · subst hslot'
          simp [hslot]
        · simp [hslot, hslot']
    · intro baseSlot addr haddr
      simp at haddr
      rcases haddr with rfl | rfl
      · simp
      · simp

theorem simpleToken_balanceOf_correct (storedBal totalSupply : Nat) (addr ownerAddr senderAddr : Address)
    :
  let spec := simpleTokenSpec
  let irContract := compile spec [0x40c10f19, 0xa9059cbb, 0x70a08231, 0x18160ddd, 0x8da5cb5b]
  let initialStorage : SpecStorage :=
    ((SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 2 totalSupply)
      .setMapping 1 (addressToNat addr) storedBal
  let tx : Transaction := {
    sender := senderAddr
    functionName := "balanceOf"
    args := [addressToNat addr]
  }
  let irTx : IRTransaction := {
    sender := addressToNat senderAddr
    functionSelector := 0x70a08231
    args := [addressToNat addr]
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage senderAddr)
      resultsMatch ir.usesMapping [addr] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    simpleTokenIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.setMapping,
    SpecStorage.getSlot, SpecStorage.getMapping, specStorageToIRState]
  · intro slot
    by_cases hslot : slot = 0
    · subst hslot
      simp
    · by_cases hslot' : slot = 2
      · subst hslot'
        simp [hslot]
      · simp [hslot, hslot']
  · intro baseSlot addr' haddr
    simp at haddr
    subst haddr
    simp

theorem simpleToken_totalSupply_correct (storedSupply : Nat) (ownerAddr senderAddr : Address)
    :
  let spec := simpleTokenSpec
  let irContract := compile spec [0x40c10f19, 0xa9059cbb, 0x70a08231, 0x18160ddd, 0x8da5cb5b]
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 2 storedSupply
  let tx : Transaction := {
    sender := senderAddr
    functionName := "totalSupply"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat senderAddr
    functionSelector := 0x18160ddd
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage senderAddr)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    simpleTokenIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
    specStorageToIRState]
  · intro slot
    by_cases hslot : slot = 0
    · subst hslot
      simp
    · by_cases hslot' : slot = 2
      · subst hslot'
        simp [hslot]
      · simp [hslot, hslot']

theorem simpleToken_owner_correct (storedOwner storedSupply : Nat) (senderAddr : Address)
    :
  let spec := simpleTokenSpec
  let irContract := compile spec [0x40c10f19, 0xa9059cbb, 0x70a08231, 0x18160ddd, 0x8da5cb5b]
  let initialStorage : SpecStorage :=
    (SpecStorage.empty.setSlot 0 storedOwner).setSlot 2 storedSupply
  let tx : Transaction := {
    sender := senderAddr
    functionName := "owner"
    args := []
  }
  let irTx : IRTransaction := {
    sender := addressToNat senderAddr
    functionSelector := 0x8da5cb5b
    args := []
  }
  let specResult := interpretSpec spec initialStorage tx
  match irContract with
  | .ok ir =>
      let irResult := interpretIR ir irTx (specStorageToIRState initialStorage senderAddr)
      resultsMatch ir.usesMapping [] irResult specResult
  | .error _ => False
  := by
  simp [resultsMatch, interpretSpec, execFunction, execStmts, execStmt, evalExpr,
    interpretIR, execIRFunction, execIRStmts, execIRStmt, evalIRExpr, evalIRExprs,
    simpleTokenIRContract, SpecStorage.empty, SpecStorage.setSlot, SpecStorage.getSlot,
    specStorageToIRState]
  · intro slot
    by_cases hslot : slot = 0
    · subst hslot
      simp
    · by_cases hslot' : slot = 2
      · subst hslot'
        simp [hslot]
      · simp [hslot, hslot']

/-! ## SimpleToken: Contract-Level Preservation (Dispatch) -/

theorem simpleToken_contract_preserves_semantics
    (ownerAddr : Address) (totalSupply mintBal transferSenderBal transferRecipientBal balanceBal : Nat)
    (mintAddr transferRecipientAddr balanceAddr : Address) (tx : Transaction) :
  let spec := simpleTokenSpec
  let irContract := compile spec [0x40c10f19, 0xa9059cbb, 0x70a08231, 0x18160ddd, 0x8da5cb5b]
  match irContract with
  | .ok ir =>
      match tx.functionName, tx.args with
      | "mint", [to, amount] =>
          if to = addressToNat mintAddr then
            let initialStorage : SpecStorage :=
              ((SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 2 totalSupply)
                .setMapping 1 (addressToNat mintAddr) mintBal
            let specResult := interpretSpec spec initialStorage tx
            let irTx := transactionToIRTransaction tx 0x40c10f19
            let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
            resultsMatch ir.usesMapping [mintAddr] irResult specResult
          else
            True
      | "transfer", [recipient, amount] =>
          if recipient = addressToNat transferRecipientAddr then
            let initialStorage : SpecStorage :=
              (((SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 2 totalSupply)
                .setMapping 1 (addressToNat tx.sender) transferSenderBal)
                .setMapping 1 (addressToNat transferRecipientAddr) transferRecipientBal
            let specResult := interpretSpec spec initialStorage tx
            let irTx := transactionToIRTransaction tx 0xa9059cbb
            let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
            resultsMatch ir.usesMapping [tx.sender, transferRecipientAddr] irResult specResult
          else
            True
      | "balanceOf", [addr] =>
          if addr = addressToNat balanceAddr then
            let initialStorage : SpecStorage :=
              ((SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 2 totalSupply)
                .setMapping 1 (addressToNat balanceAddr) balanceBal
            let specResult := interpretSpec spec initialStorage tx
            let irTx := transactionToIRTransaction tx 0x70a08231
            let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
            resultsMatch ir.usesMapping [balanceAddr] irResult specResult
          else
            True
      | "totalSupply", [] =>
          let initialStorage : SpecStorage :=
            (SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 2 totalSupply
          let specResult := interpretSpec spec initialStorage tx
          let irTx := transactionToIRTransaction tx 0x18160ddd
          let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
          resultsMatch ir.usesMapping [] irResult specResult
      | "owner", [] =>
          let initialStorage : SpecStorage :=
            (SpecStorage.empty.setSlot 0 (addressToNat ownerAddr)).setSlot 2 totalSupply
          let specResult := interpretSpec spec initialStorage tx
          let irTx := transactionToIRTransaction tx 0x8da5cb5b
          let irResult := interpretIR ir irTx (specStorageToIRState initialStorage tx.sender)
          resultsMatch ir.usesMapping [] irResult specResult
      | _, _ => True
  | .error _ => False
  := by
  by_cases hmint : tx.functionName = "mint"
  · subst hmint
    cases hargs : tx.args with
    | nil =>
        simp [hargs]
    | cons to rest =>
        cases rest with
        | nil =>
            simp [hargs]
        | cons amount tail =>
            cases tail with
            | nil =>
                by_cases haddr : to = addressToNat mintAddr
                · simpa [hargs, haddr] using
                    (simpleToken_mint_correct mintBal totalSupply amount tx.sender mintAddr ownerAddr)
                · simp [hargs, haddr]
            | cons _ _ =>
                simp [hargs]
  · by_cases htrans : tx.functionName = "transfer"
    · subst htrans
      cases hargs : tx.args with
      | nil =>
          simp [hargs]
      | cons recipient rest =>
          cases rest with
          | nil =>
              simp [hargs]
          | cons amount tail =>
              cases tail with
              | nil =>
                  by_cases haddr : recipient = addressToNat transferRecipientAddr
                  · simpa [hargs, haddr] using
                      (simpleToken_transfer_correct transferSenderBal transferRecipientBal totalSupply amount
                        tx.sender transferRecipientAddr ownerAddr)
                  · simp [hargs, haddr]
              | cons _ _ =>
                  simp [hargs]
    · by_cases hbal : tx.functionName = "balanceOf"
      · subst hbal
        cases hargs : tx.args with
        | nil =>
            simp [hargs]
        | cons addr rest =>
            cases rest with
            | nil =>
                by_cases haddr : addr = addressToNat balanceAddr
                · simpa [hargs, haddr] using
                    (simpleToken_balanceOf_correct balanceBal totalSupply balanceAddr ownerAddr tx.sender)
                · simp [hargs, haddr]
            | cons _ _ =>
                simp [hargs]
      · by_cases htotal : tx.functionName = "totalSupply"
        · subst htotal
          cases hargs : tx.args with
          | nil =>
              simpa [hargs] using
                (simpleToken_totalSupply_correct totalSupply ownerAddr tx.sender)
          | cons _ _ =>
              simp [hargs]
        · by_cases howner : tx.functionName = "owner"
          · subst howner
            cases hargs : tx.args with
            | nil =>
                simpa [hargs] using
                  (simpleToken_owner_correct (addressToNat ownerAddr) totalSupply tx.sender)
            | cons _ _ =>
                simp [hargs]
          · simp [hmint, htrans, hbal, htotal, howner]

/-! ## General Preservation Theorem Template

For any contract, we want to prove:

```lean
theorem contract_preserves_semantics (spec : ContractSpec) (selectors : List Nat)
    (tx : Transaction) (state : ContractState) :
  match compile spec selectors with
  | .ok ir =>
      let selectorOpt := (spec.functions.zip selectors).find?
        (fun (f, _) => f.name == tx.functionName) |>.map (·.2)
      match selectorOpt with
      | some selector =>
          let irTx := transactionToIRTransaction tx selector
          let irState := contractStateToIRState addrs state
          let irResult := interpretIR ir irTx irState
          let specResult := interpretSpec spec (contractStateToSpecStorage state) tx
          resultsMatch ir.usesMapping [] irResult specResult
      | none => True  -- Function not found, both should fail
  | .error _ => True  -- Compilation failed
```

This is the actual preservation property we want to prove.
-/

/-! ## Proof Plan

To prove the preservation theorem, we need:

**Step 1: Expression Equivalence** (conceptual)
- Show that compiled expressions evaluate to the same values
- Cannot access compileExpr directly, but can observe through function execution

**Step 2: Statement Equivalence**
- Show that compiled statements have the same effects on state
- Storage updates, returns, reverts match between IR and Spec

**Step 3: Function Equivalence**
- Show that compiled functions produce the same results
- Parameter passing, body execution, return values all match

**Step 4: Contract Equivalence**
- Compose function proofs to get full contract correctness
- Prove the main preservation theorem

**Current File Status**:
- Sets up the proof framework ✅
- Documents the high-level strategy ✅
- Proves SimpleStorage + Counter correctness ✅
- Proves SafeCounter, Owned, OwnedCounter, Ledger, and SimpleToken correctness ✅
- Adds general-sender variants for SimpleStorage, SafeCounter, and OwnedCounter ✅
- Adds contract-level dispatch theorems for SafeCounter + OwnedCounter ✅

**Next Steps for Completion**:
1. Add contract-level dispatch theorems for Ledger and SimpleToken
2. Bridge the ContractSpec → IR theorems into automated test extraction

**Why This Approach Works**:
- Uses public API (compile function)
- Proves end-to-end correctness (what users care about)
- Compositional (prove simple contracts first, build up)
- Maintainable (doesn't depend on internal implementation details)

**Estimated Effort**:
- SimpleStorage proofs: ~50 lines (simple, 2 functions)
- Counter proofs: ~100 lines (arithmetic, 3 functions)
- General framework: ~50 lines (reusable infrastructure)
- Total for Phase 2: ~200 lines (matches original estimate)

This file establishes the verification framework for expression compilation
(indirectly through contract execution). The actual proofs will be added
incrementally, starting with SimpleStorage.
-/

end Compiler.Proofs.IRGeneration
